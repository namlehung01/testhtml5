[1,["aa3gnuj51BPKnojGhupeFg@73b7f","b6mOVasAtJh6i0r4PN3Fn3","aa3gnuj51BPKnojGhupeFg@ef5e1","aa3gnuj51BPKnojGhupeFg@438fe","7b+d9AS8lOJYywmlAPlJEC","a7YStUNeNCOKGpSntUY1g5","8aWN3s9DdAuY7AH8h96X+1","1brw/JvvpFnIvdrxpFCgMZ","e3VTytLxVCk4Waj0PHgPKJ@73b7f","0asxQqaWhAc5WvAmvDsjYj@2df3a","c5CD51rS5OqYsz3udImVsA@6c48a","ccw6dVfT1DBKo7ykeS152f","cfxTxOeVZIK668P7Hc027v","5eTUjEDjRFr6JoiUhRl+i8","5a8gG1WVFOLKgfrEqtkTLL@b47c0","6fiRp7WghI5phB3bNkrIax@6c48a","955bAq4zhCPL27F0htsdnr@6c48a","07GNmWOb9KtLtjSWZm/vRn@6c48a","aeGN7qxuBKPb9w7lUz+bqH@6c48a","a3zQCfCrBCDZJ4uf2rk5u8","700zdYHB5CTbCr6sdBBVm/","0asxQqaWhAc5WvAmvDsjYj@2b0a8","a1Vfk7d2lMpLdfsT5SGThZ","0asxQqaWhAc5WvAmvDsjYj@4a7d8","0asxQqaWhAc5WvAmvDsjYj@0e750","0asxQqaWhAc5WvAmvDsjYj@ef86b","0asxQqaWhAc5WvAmvDsjYj@426f2","0asxQqaWhAc5WvAmvDsjYj@754a2","0asxQqaWhAc5WvAmvDsjYj@71919","0asxQqaWhAc5WvAmvDsjYj@1332c","0asxQqaWhAc5WvAmvDsjYj@4d16f","0asxQqaWhAc5WvAmvDsjYj@efe84","e3VTytLxVCk4Waj0PHgPKJ@18751","e3VTytLxVCk4Waj0PHgPKJ@30732","e3VTytLxVCk4Waj0PHgPKJ@da6f3","e3VTytLxVCk4Waj0PHgPKJ@f1394","e3VTytLxVCk4Waj0PHgPKJ@4b929","e3VTytLxVCk4Waj0PHgPKJ@75ee4","8eBHF49hxDIqL20a2yi2ri","e3VTytLxVCk4Waj0PHgPKJ@39f7b","e3VTytLxVCk4Waj0PHgPKJ@a72ab"],["node","_parent","_mesh","_skeleton","_defaultClip","root","mainTexture","_effectAsset","data","asset","scene","_envmap"],[["cc.Node",["_name","_id","_prefab","_parent","_lpos","_children","_euler","_lrot","_components","_lscale"],1,4,1,5,2,5,5,9,5],["cc.PrefabInfo",["fileId","root","asset","targetOverrides"],2,1,1,9],["cc.SkeletalAnimation",["playOnLoad","_name","node","__prefab","_clips","_defaultClip"],1,1,4,3,6],["cc.SkinnedMeshRenderer",["_shadowCastingMode","node","__prefab","_materials","lightmapSettings","_skinningRoot","_mesh","_skeleton"],2,1,4,3,4,1,6,6],["cc.Material",["_states","_defines","_name","_props"],0,12],["cc.TargetInfo",["localID"],2],["cc.CompactValueTypeArray",["_unitCount","_unitElement","_length","_byteOffset"],-1],["cc.MeshRenderer",["_shadowCastingMode","node","__prefab","_materials","lightmapSettings","_mesh"],2,1,4,3,4,6],["cc.Mesh",["_native","_dataLength","_hash","_struct"],0,11],["cc.Prefab",["_name"],2],["cc.Node",["_name","_parent","_children","_prefab","_lpos","_lrot","_euler"],2,1,9,4,5,5,5],["cc.Node",["_name","_parent","_children","_prefab","_lpos","_lrot","_euler"],2,1,12,4,5,5,5],["cc.PrefabInfo",["fileId","root","instance","asset"],2,1,4,6],["cc.CompPrefabInfo",["fileId"],2],["cc.ModelLightmapSettings",[],3],["cc.SceneAsset",["_name"],2],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides"],1,9],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,4],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,8],["cc.Scene",["_children","_prefab","_globals"],3,2,4,4],["cc.TargetOverrideInfo",["propertyPath","source","sourceInfo","target","targetInfo"],2,1,4,1,4],["cc.SceneGlobals",["ambient","shadows","_skybox","fog"],3,4,4,4,4],["cc.AmbientInfo",[],3],["cc.ShadowsInfo",["_type","_enabled","_distance","_pcf","_bias","_near","_far","_orthoSize","_shadowColor"],-5,5],["cc.SkyboxInfo",["_enabled","_envmap"],2,6],["cc.FogInfo",[],3],["cc.DirectionalLight",["_illuminance","node","_staticSettings"],2,1,4],["cc.StaticLightSettings",[],3],["cc.Camera",["_clearFlags","_visibility","node"],1,1],["cc.EffectAsset",["_name","shaders","techniques"],0],["cc.Skeleton",["_name","_hash","_joints","_bindposes"],0,12],["cc.AnimationClip",["_name","_native","sample","wrapMode","enableTrsBlending","_duration","_hash","_keys","_curves"],-4,9,12],["cc.animation.HierarchyPath",["path"],2]],[[1,0,1,2,2],[6,3,0,1,2,5],[5,0,2],[14,1],[33,0,2],[13,0,2],[10,0,1,2,3,4,5,6,2],[0,0,3,2,4,7,6,2],[17,0,1,2,2],[0,0,3,5,2,4,7,9,6,2],[0,0,3,8,2,7,9,6,2],[21,0,1,2,3,4,2],[8,0,1,2,3,4],[3,1,2,3,4,5,6,7,1],[0,0,3,5,2,2],[18,0,1,2,3],[0,0,3,5,2,4,7,6,2],[5,1],[0,0,3,5,8,2,4,7,9,6,2],[2,1,0,2,3,4,5,3],[0,0,3,8,2,4,7,9,6,2],[7,0,1,2,3,4,5,2],[4,0,1,3,3],[31,0,1,2,3,4],[9,0,2],[12,0,1,2,3,2],[2,0,2,3,4,5,2],[16,0,1,2,3],[0,0,5,2,2],[0,1,2,2],[0,0,1,3,8,4,7,6,3],[0,0,3,2,4,2],[30,0,1,2,4],[32,0,1,2,3,4,5,6,7,8,8],[6,0,1,2,4],[7,1,2,3,4,5,1],[0,0,3,5,8,2,4,9,2],[0,1,3,2,2],[0,0,3,8,2,4,9,6,2],[0,0,5,8,2,4,2],[0,0,5,2,4,7,6,2],[0,0,5,2,4,2],[0,0,3,5,2,7,6,2],[0,0,3,2,4,7,9,6,2],[0,0,3,5,2,4,2],[11,0,1,2,3,4,5,6,2],[1,3,1],[3,0,1,2,3,4,5,6,7,2],[4,2,0,1,3,4],[15,0,2],[19,0,1,2,2],[20,0,1,2,1],[22,0,1,2,3,1],[23,1],[24,0,1,2,3,4,5,6,7,8,9],[25,0,1,2],[26,1],[27,0,1,2,2],[28,1],[29,0,1,2,3]],[[[[12,".bin",25852,1908930080,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":22336,"length":3516,"count":1758,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":22336,"count":349,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.0263243913650513,-0.3362765312194824,-0.03969179466366768],"maxPosition",8,[1,1.0416858196258545,0.37944579124450684,2.4551167488098145]]]],0,0,[],[],[]],[[[12,".bin",25788,2462528742,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":22272,"length":3516,"count":1758,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":22272,"count":348,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.0627228021621704,-0.22964781522750854,-0.03969179466366768],"maxPosition",8,[1,1.0608391761779785,0.271166056394577,2.4551167488098145]]]],0,0,[],[],[]],[[[12,".bin",5760,1395715433,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4752,"length":1008,"count":504,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":4752,"count":99,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-2.0139009952545166,-2.0199241638183594,-0.5083037614822388],"maxPosition",8,[1,2.0139009952545166,2.0199241638183594,0.41632819175720215]]]],0,0,[],[],[]],[[[12,".bin",19640,2930109689,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":17024,"length":2616,"count":1308,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":17024,"count":266,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.8331011533737183,-0.3728335201740265,-0.03329771012067795],"maxPosition",8,[1,0.7926641702651978,0.46718841791152954,2.0596137046813965]]]],0,0,[],[],[]],[[[12,".bin",49300,969163832,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":44032,"length":5268,"count":2634,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":44032,"count":688,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-26.697162628173828,-5.055922985076904,-21.154483795166016],"maxPosition",8,[1,60.5887565612793,11.239510536193848,12.134369850158691]]]],0,0,[],[],[]],[[[12,".bin",19640,2915387618,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":17024,"length":2616,"count":1308,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":17024,"count":266,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.7926226854324341,-0.7388861179351807,-0.05313277989625931],"maxPosition",8,[1,0.3647039830684662,0.5992574691772461,2.038058042526245]]]],0,0,[],[],[]],[[[12,".bin",25660,3602215295,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":22144,"length":3516,"count":1758,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":22144,"count":346,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.9536016583442688,-0.38312095403671265,-0.05688628926873207],"maxPosition",8,[1,0.487619012594223,0.4689179062843323,1.8973422050476074]]]],0,0,[],[],[]],[[[12,".bin",25660,1913840364,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":22144,"length":3516,"count":1758,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":22144,"count":346,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.091290831565857,-0.41489967703819275,-0.07584762573242188],"maxPosition",8,[1,0.9092828035354614,0.5096479654312134,2.450913906097412]]]],0,0,[],[],[]],[[[12,".bin",19838,276433534,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":17216,"length":2622,"count":1311,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":17216,"count":269,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.7611004710197449,-0.18266357481479645,-0.06545485556125641],"maxPosition",8,[1,0.961718738079071,0.5065948367118835,2.02461838722229]]]],0,0,[],[],[]],[[[12,".bin",19838,2103118564,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":17216,"length":2622,"count":1311,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":17216,"count":269,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.49995025992393494,-0.4541564881801605,-0.09076808393001556],"maxPosition",8,[1,0.9192519783973694,0.6330084204673767,2.026685953140259]]]],0,0,[],[],[]],[[[24,"grassGoup"],[28,"grassGoup",[-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13],[0,"e5Peksu5tL9peMeABb8/JC",-1,0]],[36,"grass",1,[-15],[[26,true,-14,[5,"11JgtTUn5OJKE3LJ8pTj/2"],[3],4]],[0,"87M1Av0v5LhZ3LsJOTzwr3",1,0],[1,-0.852,0.892,-1.49],[1,1.8,1.8,1.8]],[14,"RootNode",2,[-16,-17,-18],[0,"54SHCY049LyqH1HRGY3ZVR",1,0]],[18,"grass",1,[-20],[[26,true,-19,[5,"abXR2STONCQrmlGd7QjDWb"],[8],9]],[0,"8avX4W7ZtLOLCZ8n5QtiPm",1,0],[1,1.271,0.836,-2.68],[3,0,-0.09886819763876702,0,0.9951005373808527],[1,1.4,1.4,1.4],[1,0,-11.348,0]],[14,"RootNode",4,[-21,-22,-23],[0,"bdiB2XMldLgpbPP0u9vyiH",1,0]],[18,"grass",1,[-25],[[19,"grass<SkeletalAnimation>",true,-24,[5,"3eRlu7+XFMf4IKjhzVuyYo"],[13],14]],[0,"5fAmHUz0xO9YFym/gsZawP",1,0],[1,0.816,0.874,-2.029],[3,0.009594606467145706,-0.09840154486124139,-0.09656895017241425,0.9904037143297977],[1,1.8,1.8,1.8],[1,0,-11.348,-11.138]],[14,"RootNode",6,[-26,-27,-28],[0,"0cYonIu91LHamoapMUydbc",1,0]],[18,"grass",1,[-30],[[19,"grass<SkeletalAnimation>",true,-29,[5,"22rvun9aNNBbAK//dWXzkX"],[18],19]],[0,"9bIVhdYYpFl7JZmL4oubNS",1,0],[1,1.505,0.835,-2.352],[3,0.009051343059323664,0.011005731118140823,-0.042668681053864996,0.9989876529409666],[1,1.8,1.8,1.8],[1,1.094,1.309,-4.879]],[14,"RootNode",8,[-31,-32,-33],[0,"2at9CGY1VK9qtNpM8kC/KU",1,0]],[18,"grass",1,[-35],[[19,"grass<SkeletalAnimation>",true,-34,[5,"0f8P8jwTVOzaIGGhmhMYJ6"],[23],24]],[0,"2d66RAsipF1brG2RGpHJY1",1,0],[1,2.591,0.697,-3.192],[3,-0.009569056200142995,-0.27238145223532967,-0.02174826425431747,0.961895935454317],[1,1.4,1.4,1.4],[1,-1.735,-31.653,-2.099]],[14,"RootNode",10,[-36,-37,-38],[0,"75DE0pyqBGsIOI2RSOFxap",1,0]],[18,"grass",1,[-40],[[19,"grass<SkeletalAnimation>",true,-39,[5,"b6LjWqcFFEYa267NpDVpBB"],[28],29]],[0,"ffwse8PqZBf4sIEkNdsA+i",1,0],[1,-2.85,0.766,-2.616],[3,-0.007707220961668685,-0.0985673335815995,0.07757256533280044,0.9920723646001587],[1,1.8,1.8,1.8],[1,0,-11.348,8.942]],[14,"RootNode",12,[-41,-42,-43],[0,"12tzV7tYdKJJxbVmqiEpry",1,0]],[18,"grass",1,[-45],[[19,"grass<SkeletalAnimation>",true,-44,[5,"a5eATDuwJGuL6l09vX0n3S"],[33],34]],[0,"adNP+ELEhC4awfcKkY8jYJ",1,0],[1,-3.252,0.663,-3.355],[3,-0.005303598000440666,-0.09872584440048117,0.053380291603709065,0.9936677633716235],[1,1.6,1.6,1.6],[1,9.996766443584073e-17,-11.348,6.150000000000002]],[14,"RootNode",14,[-46,-47,-48],[0,"0eVA3+ezRBf4EQOOoMIo4S",1,0]],[18,"grass",1,[-50],[[19,"grass<SkeletalAnimation>",true,-49,[5,"8fKHzMP19M76liKGOWy5fp"],[38],39]],[0,"33gYFxG8dO2r8iKjzjEx4z",1,0],[1,-4.716,0.534,-2.539],[3,-0.011417842217574529,0.10201162854238845,0.09441482697624534,0.9902267926936081],[1,1.2999999999999998,1.3,1.3],[1,-2.442,11.991,10.641]],[14,"RootNode",16,[-51,-52,-53],[0,"53OGGCuwFNs4KQ0nQRdow5",1,0]],[18,"grass",1,[-55],[[19,"grass<SkeletalAnimation>",true,-54,[5,"63dAWSpBBOqo5RjIXi5sEW"],[43],44]],[0,"27mCip0lFNkL+6Dj/Bpwj4",1,0],[1,-3.151,0.706,-2.905],[3,-0.01606605470413201,0.10576273729137807,0.0511818299419083,0.9929433748057723],[1,1.6,1.6,1.6],[1,-2.461,12.281,5.638]],[14,"RootNode",18,[-56,-57,-58],[0,"560/1xR41BPKG+lcc5935I",1,0]],[18,"grass",1,[-60],[[19,"grass<SkeletalAnimation>",true,-59,[5,"5c8UINxBNN1bAOwYYO6ZIW"],[48],49]],[0,"50aim7sdtB2rmsHB4KRkd5",1,0],[1,2.179,0.714,-3.159],[3,0.0002046174412504865,-0.2725489284000769,-0.05622568582446521,0.9604976376926917],[1,1.4,1.4,1.4],[1,-1.744,-31.778,-6.207]],[14,"RootNode",20,[-61,-62,-63],[0,"25mf8t9bhJIo3E0lcGCo1H",1,0]],[18,"grass",1,[-65],[[19,"grass<SkeletalAnimation>",true,-64,[5,"2dbXeRDsVAWK67o3tGgUEl"],[53],54]],[0,"70DWXrCRRL4pWATtzgi7DN",1,0],[1,5.041,0.406,-3.58],[3,0.026333680128465056,-0.27127042474669716,-0.14805365417229147,0.9506834433368816],[1,1.4,1.4,1.4],[1,-1.815,-32.126,-17.205]],[14,"RootNode",22,[-66,-67,-68],[0,"9dXaYb8ytBBb2yYH4yN6Vh",1,0]],[18,"grass",1,[-70],[[19,"grass<SkeletalAnimation>",true,-69,[5,"42733HPMdIEqobiaBVXbRJ"],[58],59]],[0,"7aOtJ3fThN27Zj4fmkg0ut",1,0],[1,4.153,0.548,-3.566],[3,0.01263456693718553,-0.27225485806840527,-0.09997674733537244,0.9569338064718487],[1,1.4,1.4,1.4],[1,-1.769,-31.94,-11.433]],[14,"RootNode",24,[-71,-72,-73],[0,"fa4L3FVuFMwYhNq67HoU7c",1,0]],[10,"grass",3,[[13,-74,[5,"a6J1jU/r1BPKNIcVMEREit"],[0],[3],2,1,2]],[0,"5fs1r6h0xEiJFeWVPk8SNl",1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[9,"Bone001",3,[-75],[0,"daWdShf/9NHLgm8BB+DJZm",1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[6,"Bone002",27,[[7,"Bone003",-76,[0,"8e/dPEvbdIMo48q55vpZZ3",1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"beKna0bXZNtrHWMkpFZoVU",1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[9,"Bone004",3,[-77],[0,"94aP4+w7dE/qUrh7Cfcv3Y",1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[6,"Bone005",29,[[7,"Bone006",-78,[0,"96ATlvvpZKqpZWVYxnyW6U",1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"8fu8biB4BPFKtDBKsYv4K/",1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[10,"grass",5,[[13,-79,[5,"28WH2cvhNDFbN3it+8Q+XK"],[5],[3],4,6,7]],[0,"74Q+wg/aVBj5Bkvd+Cqz4L",1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[9,"Bone001",5,[-80],[0,"4fGc2baulLjbJeePpPYcqt",1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[6,"Bone002",32,[[7,"Bone003",-81,[0,"af9wSIs/ZHx5FXOjfa1Jum",1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"25LOOT8GBDpr0h1KIC5gCx",1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[9,"Bone004",5,[-82],[0,"b8DSzxi5tJyKiMnjvG0NLg",1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[6,"Bone005",34,[[7,"Bone006",-83,[0,"65QAhjUVBAtLwEci9t05Ey",1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"e75gT5ogJMOoh/2sggS7OQ",1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[10,"grass",7,[[13,-84,[5,"87exLhmM1P35jx6GLN7j5f"],[10],[3],6,11,12]],[0,"60njdFxDhJWowG9HZr9kRy",1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[9,"Bone001",7,[-85],[0,"dfSzBMugdCkL5lyChYPcpt",1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[6,"Bone002",37,[[7,"Bone003",-86,[0,"91jR835RZHKbRhzSn1x2pJ",1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"3bw6IJ5hBJ0aqjcninjsA3",1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[9,"Bone004",7,[-87],[0,"36km6+kJtJZ4iiy8pwU3RO",1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[6,"Bone005",39,[[7,"Bone006",-88,[0,"977HJ5Wy5HiapZRnYB3I8X",1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"3da6ppQblGu7DGQDIjczFt",1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[10,"grass",9,[[13,-89,[5,"dduLonFhNK+q908BUlLM7f"],[15],[3],8,16,17]],[0,"f2zxp5nX1CJq18JC2EndYO",1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[9,"Bone001",9,[-90],[0,"3c+BtM6atJC4XerbYlNlM0",1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[6,"Bone002",42,[[7,"Bone003",-91,[0,"baL59AVvRKlKmpQqSjNAYI",1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"89NJAVd1tBZ6C0iX/YbeY2",1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[9,"Bone004",9,[-92],[0,"9byDe6eNtGPIztX4VSZKlQ",1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[6,"Bone005",44,[[7,"Bone006",-93,[0,"6fAgsRfRRHeoZrCvNeGhDK",1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"8exO45eF5F2KzRxFbNE1M/",1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[10,"grass",11,[[13,-94,[5,"af0f1GeGlKf5MvKMEuH8MJ"],[20],[3],10,21,22]],[0,"a2WxB7prNBKZLuuRtE7RC2",1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[9,"Bone001",11,[-95],[0,"d9cSWZZzxJ0JJz3NZ3KYKr",1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[6,"Bone002",47,[[7,"Bone003",-96,[0,"65JgfqDUlBhq62ZblXl99a",1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"613BOOO+hIlqnTjr1LZ7yD",1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[9,"Bone004",11,[-97],[0,"daMGy+QoZIMbYWUh1/PBDR",1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[6,"Bone005",49,[[7,"Bone006",-98,[0,"4bzVNkn1hF04sTb5BrBwWZ",1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"aea82LsKdAiqVuBFPi2Vfz",1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[10,"grass",13,[[13,-99,[5,"e9BPt5G81CloUmA5IJNHIQ"],[25],[3],12,26,27]],[0,"32O+zfC79Ly5/JDvR+zPy3",1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[9,"Bone001",13,[-100],[0,"2csxgVNAlDEIWU7lnXQfKS",1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[6,"Bone002",52,[[7,"Bone003",-101,[0,"f31n3srf1OQ6ztTn+Z0+bi",1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"39pnXuaeZGe5VqFTUXoXAo",1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[9,"Bone004",13,[-102],[0,"e1Z+TO4odC37Bc8FKLNniF",1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[6,"Bone005",54,[[7,"Bone006",-103,[0,"c8HIUzEBxJx72ffmHr7Yzh",1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"82tqRzYDNKi6iXruWWHldm",1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[10,"grass",15,[[13,-104,[5,"7dt8ZZ5EBNDIxOgpt1XbGu"],[30],[3],14,31,32]],[0,"3c/GljN9JNKpGUQDJiCaAz",1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[9,"Bone001",15,[-105],[0,"17tlC2EGZMWoKAixVNAp0A",1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[6,"Bone002",57,[[7,"Bone003",-106,[0,"9fnTS8hnVIWqrzTdhgEpre",1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"77DlSvZMVCFLNlyGWiwIha",1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[9,"Bone004",15,[-107],[0,"d1EnMgh6RE7o+kI5cUNlG0",1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[6,"Bone005",59,[[7,"Bone006",-108,[0,"8cUixi2TpMHINjSklAPeYi",1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"b7XmnH2bBCVpvgTAKnVXA2",1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[10,"grass",17,[[13,-109,[5,"c4Nekl9YtKUKupS0ASX7It"],[35],[3],16,36,37]],[0,"43yCcO1I5D6qP+LJIIGKjX",1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[9,"Bone001",17,[-110],[0,"0aJTcuk/5M56nEkb+D7tN9",1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[6,"Bone002",62,[[7,"Bone003",-111,[0,"d5T2sohQVAEa4ljoSzlMKU",1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"93hV+qqgFP44pIvuByy6RE",1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[9,"Bone004",17,[-112],[0,"6etpava3ZGlovr3HG7SpRo",1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[6,"Bone005",64,[[7,"Bone006",-113,[0,"6c2sTe+khLGYrsZVSADL4H",1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"ecsSU+lvpNf7DhOOeFG7w2",1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[10,"grass",19,[[13,-114,[5,"b9cuhcVRxPvZTPHcAyE7eS"],[40],[3],18,41,42]],[0,"87cW2HzEtNk4+RMW95NbLB",1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[9,"Bone001",19,[-115],[0,"16ssZzbLdO76GQg4Dvdp/y",1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[6,"Bone002",67,[[7,"Bone003",-116,[0,"5bcVkwfGRPza49BU4T6rqn",1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"fcqb+cLDVJ3KNvBTyJYBwm",1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[9,"Bone004",19,[-117],[0,"0eRKfLOh9OdLsOOjTosv1c",1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[6,"Bone005",69,[[7,"Bone006",-118,[0,"0b/yPLcR1FiZPqyfaG8HBZ",1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"0fPapM97RGmYmlB69FuuSF",1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[10,"grass",21,[[13,-119,[5,"f3T3OFBBJBYrGbPSQ+k7GJ"],[45],[3],20,46,47]],[0,"08LJZ1ezRCiqnszI5cXQTx",1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[9,"Bone001",21,[-120],[0,"c9g0zchT9L8IQmY+99TABR",1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[6,"Bone002",72,[[7,"Bone003",-121,[0,"d8OdalQsZKwLFf2mFuR1VJ",1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"ecFy8CTgxCib8Fky/YcoUL",1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[9,"Bone004",21,[-122],[0,"91+xPZxDtGRp/x7cNrBUhM",1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[6,"Bone005",74,[[7,"Bone006",-123,[0,"66R8TA3S1NT4HLywjDiP1Q",1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"963dgjTmdES7q6KBvCTllJ",1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[10,"grass",23,[[13,-124,[5,"d0A5LfhGhAfrDnBGJ3JzOe"],[50],[3],22,51,52]],[0,"203+J3Vb1LP7KUgkjLvNtX",1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[9,"Bone001",23,[-125],[0,"9eOEdVVahA+rbDiF4AJNNX",1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[6,"Bone002",77,[[7,"Bone003",-126,[0,"3aJII/zG9KaYapX0uizphW",1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"48r+NZR1BD7Y5qEv/ruQsO",1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[9,"Bone004",23,[-127],[0,"469eCD0ttKHZacZ3xtfeuD",1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[6,"Bone005",79,[[7,"Bone006",-128,[0,"1fFpy0ihVOYbzhBLRLkL1Y",1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"d9iCqzyppAILXebiHSqtDk",1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[10,"grass",25,[[13,-129,[5,"161SEdWiFO/abXxUI8RkYk"],[55],[3],24,56,57]],[0,"80TsYKkUVBAIbPGc2Ao+X4",1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[9,"Bone001",25,[-130],[0,"54j/6cneBCF4PpXQIO+ZrT",1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[6,"Bone002",82,[[7,"Bone003",-131,[0,"6aDs2ciZhDh6tahiNmO4QO",1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"1er+9JvftCj5j548DE5PNk",1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[9,"Bone004",25,[-132],[0,"c8ON8aNTZH1YV9KZsolNGO",1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[6,"Bone005",84,[[7,"Bone006",-133,[0,"1eZ45FwjhMoY5AmDd/ApaW",1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"7fkJUsKFZMHbutZKiHcKAf",1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]]],0,[0,5,1,0,-1,2,0,-2,4,0,-3,6,0,-4,8,0,-5,10,0,-6,12,0,-7,14,0,-8,16,0,-9,18,0,-10,20,0,-11,22,0,-12,24,0,0,2,0,-1,3,0,-1,26,0,-2,27,0,-3,29,0,0,4,0,-1,5,0,-1,31,0,-2,32,0,-3,34,0,0,6,0,-1,7,0,-1,36,0,-2,37,0,-3,39,0,0,8,0,-1,9,0,-1,41,0,-2,42,0,-3,44,0,0,10,0,-1,11,0,-1,46,0,-2,47,0,-3,49,0,0,12,0,-1,13,0,-1,51,0,-2,52,0,-3,54,0,0,14,0,-1,15,0,-1,56,0,-2,57,0,-3,59,0,0,16,0,-1,17,0,-1,61,0,-2,62,0,-3,64,0,0,18,0,-1,19,0,-1,66,0,-2,67,0,-3,69,0,0,20,0,-1,21,0,-1,71,0,-2,72,0,-3,74,0,0,22,0,-1,23,0,-1,76,0,-2,77,0,-3,79,0,0,24,0,-1,25,0,-1,81,0,-2,82,0,-3,84,0,0,26,0,-1,28,0,1,28,0,-1,30,0,1,30,0,0,31,0,-1,33,0,1,33,0,-1,35,0,1,35,0,0,36,0,-1,38,0,1,38,0,-1,40,0,1,40,0,0,41,0,-1,43,0,1,43,0,-1,45,0,1,45,0,0,46,0,-1,48,0,1,48,0,-1,50,0,1,50,0,0,51,0,-1,53,0,1,53,0,-1,55,0,1,55,0,0,56,0,-1,58,0,1,58,0,-1,60,0,1,60,0,0,61,0,-1,63,0,1,63,0,-1,65,0,1,65,0,0,66,0,-1,68,0,1,68,0,-1,70,0,1,70,0,0,71,0,-1,73,0,1,73,0,-1,75,0,1,75,0,0,76,0,-1,78,0,1,78,0,-1,80,0,1,80,0,0,81,0,-1,83,0,1,83,0,-1,85,0,1,85,0,8,1,133],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,2,3,-1,4,-1,2,3,-1,4,-1,2,3,-1,4,-1,2,3,-1,4,-1,2,3,-1,4,-1,2,3,-1,4,-1,2,3,-1,4,-1,2,3,-1,4,-1,2,3,-1,4,-1,2,3,-1,4,-1,2,3,-1,4,-1,2,3,-1,4],[1,2,3,0,0,1,2,3,0,0,1,2,3,0,0,1,2,3,0,0,1,2,3,0,0,1,2,3,0,0,1,2,3,0,0,1,2,3,0,0,1,2,3,0,0,1,2,3,0,0,1,2,3,0,0,1,2,3,0,0]],[[[48,"seafloor",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.400000005960464,"roughness":0.70710676908493,"alphaThreshold":0},"albedoScale",8,[1,1,1,1],"mainTexture",6,0]],11]]],0,0,[0,0],[6,7],[9,7]],[[[22,[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}},{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}},{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}},{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],[{"USE_OUTLINE_PASS":true},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{"USE_BASE_COLOR_MAP":true}],[[{},[{},"specular",8,[4,16777215],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[6,7],[10,5]],[[[49,"main"],[29,"96ghi0rklFc4YnsYx0Rtjm",[25,"e5Peksu5tL9peMeABb8/JC",-1,[27,"7e4SH9jydKyaQjXZtS5AiQ",null,[[8,["lightmapSettings"],[2,["a6J1jU/r1BPKNIcVMEREit"]],[3]],[15,1,["_shadowReceivingMode"],[2,["a6J1jU/r1BPKNIcVMEREit"]]],[8,["lightmapSettings"],[2,["28WH2cvhNDFbN3it+8Q+XK"]],[3]],[15,1,["_shadowReceivingMode"],[2,["28WH2cvhNDFbN3it+8Q+XK"]]],[8,["lightmapSettings"],[2,["87exLhmM1P35jx6GLN7j5f"]],[3]],[15,1,["_shadowReceivingMode"],[2,["87exLhmM1P35jx6GLN7j5f"]]],[8,["lightmapSettings"],[2,["dduLonFhNK+q908BUlLM7f"]],[3]],[15,1,["_shadowCastingMode"],[2,["dduLonFhNK+q908BUlLM7f"]]],[15,1,["_shadowReceivingMode"],[2,["dduLonFhNK+q908BUlLM7f"]]],[8,["lightmapSettings"],[2,["af0f1GeGlKf5MvKMEuH8MJ"]],[3]],[15,1,["_shadowReceivingMode"],[2,["af0f1GeGlKf5MvKMEuH8MJ"]]],[8,["lightmapSettings"],[2,["e9BPt5G81CloUmA5IJNHIQ"]],[3]],[15,1,["_shadowReceivingMode"],[2,["e9BPt5G81CloUmA5IJNHIQ"]]],[8,["lightmapSettings"],[2,["7dt8ZZ5EBNDIxOgpt1XbGu"]],[3]],[15,1,["_shadowReceivingMode"],[2,["7dt8ZZ5EBNDIxOgpt1XbGu"]]],[8,["lightmapSettings"],[2,["c4Nekl9YtKUKupS0ASX7It"]],[3]],[15,1,["_shadowReceivingMode"],[2,["c4Nekl9YtKUKupS0ASX7It"]]],[8,["lightmapSettings"],[2,["b9cuhcVRxPvZTPHcAyE7eS"]],[3]],[15,1,["_shadowReceivingMode"],[2,["b9cuhcVRxPvZTPHcAyE7eS"]]],[8,["lightmapSettings"],[2,["f3T3OFBBJBYrGbPSQ+k7GJ"]],[3]],[15,1,["_shadowReceivingMode"],[2,["f3T3OFBBJBYrGbPSQ+k7GJ"]]],[8,["lightmapSettings"],[2,["d0A5LfhGhAfrDnBGJ3JzOe"]],[3]],[15,1,["_shadowReceivingMode"],[2,["d0A5LfhGhAfrDnBGJ3JzOe"]]],[8,["lightmapSettings"],[2,["161SEdWiFO/abXxUI8RkYk"]],[3]],[15,1,["_shadowReceivingMode"],[2,["161SEdWiFO/abXxUI8RkYk"]]]]],2]],[29,"fcY5TMXBxOuo8tyzFfp6B9",[25,"6dMvPN2t1B66O9Zc3HG8dr",-2,[27,"93xtJEZ71OF5Gk8u497J9k",null,[[8,["lightmapSettings"],[2,["78XZsd31xPjIsSP2888FcN"]],[3]],[8,["lightmapSettings"],[2,["ffoVYmt2NOmIBz5DHpacF8"]],[3]],[8,["lightmapSettings"],[2,["9aCVBuMeZPv6so1VxT6c40"]],[3]],[8,["lightmapSettings"],[2,["ca1srfPsJJgKKJww9GO/JE"]],[3]]]],1]],[51,[-3,-4,-5,2,1],[46,[[11,["_skinningRoot"],2,[2,["04W3Kzvb9BZbZUGFZzfzi5"]],2,[2,["6dMvPN2t1B66O9Zc3HG8dr"]]],[11,["_skinningRoot"],2,[2,["04W3Kzvb9BZbZUGFZzfzi5"]],2,[2,["6dMvPN2t1B66O9Zc3HG8dr"]]],[11,["_skinningRoot"],2,[2,["04W3Kzvb9BZbZUGFZzfzi5"]],2,[2,["6dMvPN2t1B66O9Zc3HG8dr"]]],[11,["_skinningRoot"],2,[2,["04W3Kzvb9BZbZUGFZzfzi5"]],2,[2,["6dMvPN2t1B66O9Zc3HG8dr"]]],[11,["_skinningRoot"],1,[17],1,[2,["87M1Av0v5LhZ3LsJOTzwr3"]]],[11,["_skinningRoot"],1,[17],1,[2,["8avX4W7ZtLOLCZ8n5QtiPm"]]],[11,["_skinningRoot"],1,[17],1,[2,["5fAmHUz0xO9YFym/gsZawP"]]],[11,["_skinningRoot"],1,[17],1,[2,["9bIVhdYYpFl7JZmL4oubNS"]]],[11,["_skinningRoot"],1,[17],1,[2,["2d66RAsipF1brG2RGpHJY1"]]],[11,["_skinningRoot"],1,[17],1,[2,["ffwse8PqZBf4sIEkNdsA+i"]]],[11,["_skinningRoot"],1,[17],1,[2,["adNP+ELEhC4awfcKkY8jYJ"]]],[11,["_skinningRoot"],1,[17],1,[2,["33gYFxG8dO2r8iKjzjEx4z"]]],[11,["_skinningRoot"],1,[17],1,[2,["27mCip0lFNkL+6Dj/Bpwj4"]]],[11,["_skinningRoot"],1,[17],1,[2,["50aim7sdtB2rmsHB4KRkd5"]]],[11,["_skinningRoot"],1,[17],1,[2,["70DWXrCRRL4pWATtzgi7DN"]]],[11,["_skinningRoot"],1,[17],1,[2,["7aOtJ3fThN27Zj4fmkg0ut"]]]]],[52,[53],[54,1,true,1,2,0.0035,0.1,50,10,[4,1929379840]],[55,true,3],[56]]],[30,"Main Light","c0y6F5f+pAvI805TdmxIjx",3,[[57,125000,-6,[58]]],[1,-2.955,3.412,5.118],[3,-0.24999999999999997,-0.24999999999999997,-0.06698729810778066,0.9330127018922194],[1,-30,-30,0]],[30,"Main Camera","c9DMICJLFO5IeO07EPon7U",3,[[59,14,1820327937,-7]],[1,0.4563737338172984,4.020698998822525,7.83104356477376],[3,-0.07236081996736556,0.03501809641207027,0.002542173940871125,0.9967603433167774],[1,-8.304321541008003,4.024165472580301,9.93923337957349e-17]],[37,"6dkcA2pVdK6o9h8rGVX3bm",3,[25,"26LvC5hbxAuJZ9Jl2SB/IV",-8,[27,"cdNOYl3LRPhapW8a8hi/Iy",null,[[8,["lightmapSettings"],[2,["ddvMFij+ZIL5lu+/NQX8Nf"]],[3]],[8,["lightmapSettings"],[2,["e3XMjUJKFLH41z39JaWzyB"]],[3]],[50,["position"],[2,["fd517lz3tOuqVWGd5300X6"]],[1,-1.341,0.805,-2.555]],[8,["lightmapSettings"],[2,["a5Viy6l3VLDpf6gY5yZF+v"]],[3]],[15,1,["_shadowCastingMode"],[2,["a5Viy6l3VLDpf6gY5yZF+v"]]],[8,["lightmapSettings"],[2,["e4If/bQrJCsb9D9JopZa2h"]],[3]],[8,["lightmapSettings"],[2,["d7Vkz0NV5Mn4RUce28JVTp"]],[3]],[8,["lightmapSettings"],[2,["3eVATgLQJKDbqOvE33W2uc"]],[3]],[8,["lightmapSettings"],[2,["2akU/MgO5Ovo6QcS0c/I7e"]],[3]],[8,["lightmapSettings"],[2,["54xaKIQbtPLK5r21VY0qmM"]],[3]],[8,["lightmapSettings"],[2,["23UFBqszxJ/6Otof04QwYT"]],[3]],[8,["lightmapSettings"],[2,["c7PE6gNTdDw45ytwlOEWR3"]],[3]]]],0]]],0,[0,5,1,0,5,2,0,-1,4,0,-2,5,0,-3,6,0,0,4,0,0,5,0,5,6,0,10,3,1,1,3,2,1,3,8],[0,0,0,0],[9,9,9,11],[11,12,13,14]],[[[22,[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}},{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}},{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}},{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],[{"USE_OUTLINE_PASS":true},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{"USE_BASE_COLOR_MAP":true}],[[{},[{},"specular",8,[4,16777215],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[6,7],[15,5]],[[[22,[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}},{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}},{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],[{"USE_ALBEDO_MAP":true},{"USE_ALBEDO_MAP":true},{"USE_ALBEDO_MAP":true}],[[[{"alphaThreshold":0,"roughness":0.70710676908493,"metallic":0.400000005960464},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[6,7],[16,7]],[[[22,[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}},{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}},{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}},{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],[{"USE_OUTLINE_PASS":true},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{"USE_BASE_COLOR_MAP":true}],[[{},[{},"specular",8,[4,16777215],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[6,7],[17,5]],[[[32,"builtin-unlit",[{"hash":1017648509,"name":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nlayout(location = 0) out float v_fog_factor;\n#if USE_VERTEX_COLOR\n  layout(location = 13) in lowp vec4 a_color;\n  layout(location = 1) out lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\n  layout(location = 2) out vec2 v_uv;\n  layout(set = 1, binding = 0) uniform TexCoords {\n    vec4 tilingOffset;\n  };\n#endif\nvec4 vert () {\n  vec4 position;\n      position = vec4(a_position, 1.0);\n    #if CC_USE_MORPH\n      applyMorph(position);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(position);\n    #endif\n  mat4 matWorld;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    #else\n      matWorld = cc_matWorld;\n    #endif\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n    #if CC_USE_FOG == 0\n      v_fog_factor = LinearFog(matWorld * position);\n    #elif CC_USE_FOG == 1\n      v_fog_factor = ExpFog(matWorld * position);\n    #elif CC_USE_FOG == 2\n      v_fog_factor = ExpSquaredFog(matWorld * position);\n    #elif CC_USE_FOG == 3\n      v_fog_factor = LayeredFog(matWorld * position);\n    #else\n      v_fog_factor = 1.0;\n    #endif\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in float v_fog_factor;\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  layout(location = 2) in vec2 v_uv;\n  layout(set = 1, binding = 2) uniform sampler2D mainTexture;\n#endif\nlayout(set = 1, binding = 1) uniform Constant {\n  vec4 mainColor;\n  vec4 colorScaleAndCutoff;\n};\n#if USE_VERTEX_COLOR\n  layout(location = 1) in lowp vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o *= v_color;\n  #endif\n  #if USE_TEXTURE\n    o *= texture(mainTexture, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  o = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, o.rgb, v_fog_factor), o.a);\n  return CCFragOutput(o);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nout float v_fog_factor;\n#if USE_VERTEX_COLOR\n  in lowp vec4 a_color;\n  out lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\n  out vec2 v_uv;\n  layout(std140) uniform TexCoords {\n    vec4 tilingOffset;\n  };\n#endif\nvec4 vert () {\n  vec4 position;\n      position = vec4(a_position, 1.0);\n    #if CC_USE_MORPH\n      applyMorph(position);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(position);\n    #endif\n  mat4 matWorld;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    #else\n      matWorld = cc_matWorld;\n    #endif\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n    #if CC_USE_FOG == 0\n      v_fog_factor = LinearFog(matWorld * position);\n    #elif CC_USE_FOG == 1\n      v_fog_factor = ExpFog(matWorld * position);\n    #elif CC_USE_FOG == 2\n      v_fog_factor = ExpSquaredFog(matWorld * position);\n    #elif CC_USE_FOG == 3\n      v_fog_factor = LayeredFog(matWorld * position);\n    #else\n      v_fog_factor = 1.0;\n    #endif\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin float v_fog_factor;\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  in vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\nlayout(std140) uniform Constant {\n  vec4 mainColor;\n  vec4 colorScaleAndCutoff;\n};\n#if USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o *= v_color;\n  #endif\n  #if USE_TEXTURE\n    o *= texture(mainTexture, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  o = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, o.rgb, v_fog_factor), o.a);\n  return CCFragOutput(o);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n#endif\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvarying float v_fog_factor;\n#if USE_VERTEX_COLOR\n  attribute lowp vec4 a_color;\n  varying lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\n  varying vec2 v_uv;\n      uniform vec4 tilingOffset;\n#endif\nvec4 vert () {\n  vec4 position;\n      position = vec4(a_position, 1.0);\n    #if CC_USE_MORPH\n      applyMorph(position);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(position);\n    #endif\n  mat4 matWorld;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    #else\n      matWorld = cc_matWorld;\n    #endif\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n    #if CC_USE_FOG == 0\n      v_fog_factor = LinearFog(matWorld * position);\n    #elif CC_USE_FOG == 1\n      v_fog_factor = ExpFog(matWorld * position);\n    #elif CC_USE_FOG == 2\n      v_fog_factor = ExpSquaredFog(matWorld * position);\n    #elif CC_USE_FOG == 3\n      v_fog_factor = LayeredFog(matWorld * position);\n    #else\n      v_fog_factor = 1.0;\n    #endif\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nuniform mediump vec4 cc_exposure;\n  uniform mediump vec4 cc_fogColor;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying float v_fog_factor;\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  varying vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\n   uniform vec4 mainColor;\n   uniform vec4 colorScaleAndCutoff;\n#if USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o *= v_color;\n  #endif\n  #if USE_TEXTURE\n    o *= texture2D(mainTexture, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  o = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, o.rgb, v_fog_factor), o.a);\n  return CCFragOutput(o);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":195,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":39}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_FOG","type":"number","defines":[],"range":[0,4]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"USE_VERTEX_COLOR","type":"boolean","defines":[]},{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":["USE_TEXTURE"]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r","g","b"]}],"blocks":[{"name":"TexCoords","stageFlags":1,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1}],"defines":["USE_TEXTURE"]},{"name":"Constant","stageFlags":16,"binding":1,"members":[{"name":"mainColor","type":16,"count":1},{"name":"colorScaleAndCutoff","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_TEXTURE"]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord","type":14,"count":1,"stageFlags":1,"format":21,"location":2,"defines":[]},{"name":"a_tangent","type":16,"count":1,"stageFlags":1,"format":44,"location":3,"defines":[]},{"name":"a_vertexId","type":13,"count":1,"stageFlags":1,"format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","type":"u32vec4","count":1,"stageFlags":1,"location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","type":16,"count":1,"stageFlags":1,"format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","type":13,"count":1,"stageFlags":1,"format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_color","type":16,"count":1,"stageFlags":1,"format":44,"location":13,"defines":["USE_VERTEX_COLOR"]}],"varyings":[{"name":"v_fog_factor","type":13,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"v_color","type":16,"count":1,"stageFlags":1,"location":1,"defines":["USE_VERTEX_COLOR"]},{"name":"v_uv","type":14,"count":1,"stageFlags":1,"location":2,"defines":["USE_TEXTURE"]}]}],[{"name":"opaque","passes":[{"program":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"color":{"type":16,"editor":{"visible":false},"handleInfo":["mainColor",0,16]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}},"migrations":{"properties":{"mainColor":{"formerlySerializedAs":"color"}}}}]},{"name":"transparent","passes":[{"program":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"color":{"type":16,"editor":{"visible":false},"handleInfo":["mainColor",0,16]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}},"migrations":{"properties":{"mainColor":{"formerlySerializedAs":"color"}}}}]},{"name":"add","passes":[{"program":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"color":{"type":16,"editor":{"visible":false},"handleInfo":["mainColor",0,16]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}},"migrations":{"properties":{"mainColor":{"formerlySerializedAs":"color"}}}}]},{"name":"alpha-blend","passes":[{"program":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":2,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"color":{"type":16,"editor":{"visible":false},"handleInfo":["mainColor",0,16]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}},"migrations":{"properties":{"mainColor":{"formerlySerializedAs":"color"}}}}]}]]],0,0,[],[],[]],[[[32,"builtin-toon",[{"hash":3976454846,"name":"builtin-toon|outline-vs:vert|outline-fs:frag","glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(location = 0) out vec2 v_uv;\nlayout(set = 1, binding = 0) uniform OutlineVert {\n  vec4 outlineParams;\n};\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    #else\n      matWorld = cc_matWorld;\n    #endif\n  float width = outlineParams.x * 0.001;\n  #if USE_POSITION_SCALING\n    vec3 dir = normalize(In.position.xyz);\n    float flip = dot(dir, normalize(In.normal)) < 0.0 ? -1.0 : 1.0;\n    In.position.xyz += flip * dir * width * 2.0;\n    vec4 pos = cc_matProj * (cc_matView * matWorld) * In.position;\n  #else\n    In.position.xyz += normalize(In.normal) * width;\n    vec4 pos = cc_matProj * (cc_matView * matWorld) * In.position;\n  #endif\n  pos.z -= outlineParams.y * 0.002;\n  v_uv = a_texCoord;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 v_uv;\nlayout(set = 1, binding = 1) uniform OutlineFrag {\n  vec4 baseColor;\n};\n#if USE_BASE_COLOR_MAP\n  layout(set = 1, binding = 2) uniform sampler2D baseColorMap;\n#endif\nvec4 frag () {\n  vec4 color = baseColor * cc_mainLitColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 texColor = texture(baseColorMap, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    color *= texColor;\n  #endif\n  return CCFragOutput(vec4(color.rgb, 1.0));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nout vec2 v_uv;\nlayout(std140) uniform OutlineVert {\n  vec4 outlineParams;\n};\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    #else\n      matWorld = cc_matWorld;\n    #endif\n  float width = outlineParams.x * 0.001;\n  #if USE_POSITION_SCALING\n    vec3 dir = normalize(In.position.xyz);\n    float flip = dot(dir, normalize(In.normal)) < 0.0 ? -1.0 : 1.0;\n    In.position.xyz += flip * dir * width * 2.0;\n    vec4 pos = cc_matProj * (cc_matView * matWorld) * In.position;\n  #else\n    In.position.xyz += normalize(In.normal) * width;\n    vec4 pos = cc_matProj * (cc_matView * matWorld) * In.position;\n  #endif\n  pos.z -= outlineParams.y * 0.002;\n  v_uv = a_texCoord;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 v_uv;\nlayout(std140) uniform OutlineFrag {\n  vec4 baseColor;\n};\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\nvec4 frag () {\n  vec4 color = baseColor * cc_mainLitColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 texColor = texture(baseColorMap, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    color *= texColor;\n  #endif\n  return CCFragOutput(vec4(color.rgb, 1.0));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n#endif\nvarying vec2 v_uv;\n   uniform vec4 outlineParams;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    #else\n      matWorld = cc_matWorld;\n    #endif\n  float width = outlineParams.x * 0.001;\n  #if USE_POSITION_SCALING\n    vec3 dir = normalize(In.position.xyz);\n    float flip = dot(dir, normalize(In.normal)) < 0.0 ? -1.0 : 1.0;\n    In.position.xyz += flip * dir * width * 2.0;\n    vec4 pos = cc_matProj * (cc_matView * matWorld) * In.position;\n  #else\n    In.position.xyz += normalize(In.normal) * width;\n    vec4 pos = cc_matProj * (cc_matView * matWorld) * In.position;\n  #endif\n  pos.z -= outlineParams.y * 0.002;\n  v_uv = a_texCoord;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nuniform mediump vec4 cc_exposure;\n  uniform mediump vec4 cc_mainLitColor;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 v_uv;\n   uniform vec4 baseColor;\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\nvec4 frag () {\n  vec4 color = baseColor * cc_mainLitColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 texColor = texture2D(baseColorMap, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    color *= texColor;\n  #endif\n  return CCFragOutput(vec4(color.rgb, 1.0));\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":195,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":38}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"USE_POSITION_SCALING","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_BASE_COLOR_MAP","type":"boolean","defines":[]}],"blocks":[{"name":"OutlineVert","stageFlags":1,"binding":0,"members":[{"name":"outlineParams","type":16,"count":1}],"defines":[]},{"name":"OutlineFrag","stageFlags":16,"binding":1,"members":[{"name":"baseColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"baseColorMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_BASE_COLOR_MAP"]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord","type":14,"count":1,"stageFlags":1,"format":21,"location":2,"defines":[]},{"name":"a_tangent","type":16,"count":1,"stageFlags":1,"format":44,"location":3,"defines":[]},{"name":"a_vertexId","type":13,"count":1,"stageFlags":1,"format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","type":"u32vec4","count":1,"stageFlags":1,"location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","type":16,"count":1,"stageFlags":1,"format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","type":13,"count":1,"stageFlags":1,"format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":1,"location":0,"defines":[]}]},{"hash":295467465,"name":"builtin-toon|toon-vs:vert|toon-fs:frag","glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 baseColor;\n  vec4 colorScaleAndCutoff;\n  vec4 shadeColor1;\n  vec4 shadeColor2;\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nlayout(location = 0) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform sampler2D cc_spotLightingMap;\n#endif\nlayout(location = 1) out vec3 v_position;\nlayout(location = 2) out vec2 v_uv;\nlayout(location = 3) out vec3 v_normal;\n#if USE_NORMAL_MAP\n  layout(location = 4) out vec3 v_tangent;\n  layout(location = 5) out vec3 v_bitangent;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  v_normal = (matWorldIT * vec4(In.normal, 0.0)).xyz;\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nstruct ToonSurface {\n  vec4 baseColor;\n  vec4 specular;\n  vec3 position;\n  vec3 normal;\n  vec3 shade1;\n  vec3 shade2;\n  vec3 emissive;\n  float baseStep;\n  float baseFeather;\n  float shadeStep;\n  float shadeFeather;\n};\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  layout(set = 2, binding = 1) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  vec4 CCToonShading (ToonSurface s) {\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    vec3 N = normalize(s.normal);\n    float specularWeight = 1.0 - pow(s.specular.a, 5.0);\n    vec3 finalColor = vec3(0.0);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = 0.5 * dot(N, SL) + 0.5;\n      float SNH = 0.5 * dot(N, SH) + 0.5;\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr , distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 diffuse = mix(s.shade1, s.shade2,\n        clamp(1.0 + (s.shadeStep - s.shadeFeather - SNL) / s.shadeFeather, 0.0, 1.0));\n      diffuse = mix(s.baseColor.rgb, diffuse,\n        clamp(1.0 + (s.baseStep - s.baseFeather - SNL) / s.baseFeather, 0.0, 1.0));\n      float specularMask = step(specularWeight, SNH);\n      vec3 specular = s.specular.rgb * specularMask;\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      finalColor += SNL * cc_lightColor[i].rgb * cc_lightColor[i].a * illum * att * s.baseStep * (diffuse + specular);\n    }\n    return vec4(finalColor, 0.0);\n  }\n#else\n  #if CC_RECEIVE_SHADOW\n    layout(location = 0) in highp vec4 v_shadowPos;\n    layout(set = 0, binding = 2) uniform CCShadow {\n      highp mat4 cc_matLightPlaneProj;\n      highp mat4 cc_matLightView;\n      highp mat4 cc_matLightViewProj;\n      lowp  vec4 cc_shadowNFLSInfo;\n      lowp  vec4 cc_shadowWHPBInfo;\n      lowp  vec4 cc_shadowLPNNInfo;\n      lowp  vec4 cc_shadowColor;\n    };\n    #if CC_RECEIVE_SHADOW\n      layout(set = 0, binding = 3) uniform sampler2D cc_shadowMap;\n      layout(set = 0, binding = 5) uniform sampler2D cc_spotLightingMap;\n      float CCGetShadowFactorX1 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float shadow = 0.0;\n        float closestDepth = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n        } else {\n          closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n        }\n        shadow = step(closestDepth, clipPos.z- cc_shadowWHPBInfo.w);\n        return shadow;\n      }\n      float CCGetShadowFactorX5 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n        float offsety = 1.0 / cc_shadowWHPBInfo.y;\n        float shadow = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          float closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        } else {\n          float closestDepth = texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        }\n        return shadow / 5.0;\n      }\n      float CCGetShadowFactorX9 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n        float offsety = 1.0 / cc_shadowWHPBInfo.y;\n        float shadow = 0.0;\n        float closestDepth = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          for (int i = -1; i <= 1; i++) {\n              for (int j = -1; j <= 1; j++) {\n                float closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n                shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n              }\n          }\n        } else {\n          for (int i = -1; i <= 1; i++) {\n              for (int j = -1; j <= 1; j++) {\n                float closestDepth = texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n                shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n              }\n          }\n        }\n        return shadow / 9.0;\n      }\n      float CCGetShadowFactorX25 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n        float offsety = 1.0 / cc_shadowWHPBInfo.y;\n        float shadow = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          for (int i = -2; i <= 2; i++) {\n            for (int j = -2; j <= 2; j++) {\n              float closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n              shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n            }\n          }\n        } else {\n          for (int i = -2; i <= 2; i++) {\n            for (int j = -2; j <= 2; j++) {\n              float closestDepth = texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n              shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n            }\n          }\n        }\n        return shadow / 25.0;\n      }\n    #endif\n  #endif\n  vec4 CCToonShading (ToonSurface s) {\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    vec3 N = normalize(s.normal);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    float NL = 0.5 * dot(N, L) + 0.5;\n    float NH = 0.5 * dot(normalize(V + L), N) + 0.5;\n    vec3 lightColor = cc_mainLitColor.rgb * cc_mainLitColor.w * s.baseStep;\n    vec3 diffuse = mix(s.shade1, s.shade2,\n      clamp(1.0 + (s.shadeStep - s.shadeFeather - NL) / s.shadeFeather, 0.0, 1.0));\n    diffuse = mix(s.baseColor.rgb, diffuse,\n      clamp(1.0 + (s.baseStep - s.baseFeather - NL) / s.baseFeather, 0.0, 1.0));\n    float specularWeight = 1.0 - pow(s.specular.a, 5.0);\n    float specularMask = step(specularWeight, NH);\n    vec3 specular = s.specular.rgb * specularMask;\n    vec3 finalColor = lightColor * (diffuse + specular);\n    #if CC_USE_HDR\n      s.emissive *= cc_exposure.w;\n    #endif\n    finalColor += s.emissive;\n    #if CC_RECEIVE_SHADOW\n              {\n                float pcf = cc_shadowWHPBInfo.z + 0.001;\n                float shadowAttenuation = 0.0;\n                float cosAngle = clamp(1.0 - dot(N, cc_mainLitDir.xyz), 0.0, 1.0);\n                vec3 projWorldPos = v_shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\n                vec4 pos = vec4(projWorldPos.xyz, v_shadowPos.w);\n                if (pcf > 3.0) shadowAttenuation = CCGetShadowFactorX25(pos);\n                else if (pcf > 2.0) shadowAttenuation = CCGetShadowFactorX9(pos);\n                else if (pcf > 1.0) shadowAttenuation = CCGetShadowFactorX5(pos);\n                else shadowAttenuation = CCGetShadowFactorX1(pos);\n                vec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + finalColor.rgb * (1.0 - cc_shadowColor.a);\n                if (cc_shadowNFLSInfo.w > 0.000001) {\n                  finalColor.rgb = shadowColor.rgb * shadowAttenuation + finalColor.rgb * (1.0 - shadowAttenuation);\n                } else {\n                  finalColor.rgb = shadowColor.rgb * shadowAttenuation * NL + finalColor.rgb * (1.0 - shadowAttenuation * NL);\n                }\n              }\n    #endif\n    return vec4(finalColor, s.baseColor.a);\n  }\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 baseColor;\n  vec4 colorScaleAndCutoff;\n  vec4 shadeColor1;\n  vec4 shadeColor2;\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nlayout(location = 1) in vec3 v_position;\nlayout(location = 2) in vec2 v_uv;\n#if USE_BASE_COLOR_MAP\n  layout(set = 1, binding = 1) uniform sampler2D baseColorMap;\n#endif\nlayout(location = 3) in vec3 v_normal;\n#if USE_NORMAL_MAP\n  layout(location = 4) in vec3 v_tangent;\n  layout(location = 5) in vec3 v_bitangent;\n  layout(set = 1, binding = 2) uniform sampler2D normalMap;\n#endif\n#if USE_1ST_SHADE_MAP\n  layout(set = 1, binding = 3) uniform sampler2D shadeMap1;\n#endif\n#if USE_2ND_SHADE_MAP\n  layout(set = 1, binding = 4) uniform sampler2D shadeMap2;\n#endif\n#if USE_SPECULAR_MAP\n  layout(set = 1, binding = 5) uniform sampler2D specularMap;\n#endif\n#if USE_EMISSIVE_MAP\n  layout(set = 1, binding = 6) uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out ToonSurface s) {\n  s.shade2 = shadeColor2.rgb * colorScaleAndCutoff.rgb;\n  #if USE_2ND_SHADE_MAP\n    s.shade2 *= SRGBToLinear(texture(shadeMap2, v_uv).rgb);\n  #endif\n  s.shade1 = shadeColor1.rgb * colorScaleAndCutoff.rgb;\n  #if USE_1ST_SHADE_MAP\n    s.shade1 *= SRGBToLinear(texture(shadeMap1, v_uv).rgb);\n    #if SHADE_MAP_1_AS_SHADE_MAP_2\n      s.shade2 *= s.shade1.rgb;\n    #endif\n  #endif\n  vec4 baseColor = baseColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 baseColorMap = texture(baseColorMap, v_uv);\n    baseColorMap.rgb = SRGBToLinear(baseColorMap.rgb);\n    baseColor *= baseColorMap;\n    #if BASE_COLOR_MAP_AS_SHADE_MAP_1\n      s.shade1 *= baseColorMap.rgb;\n    #endif\n    #if BASE_COLOR_MAP_AS_SHADE_MAP_2\n      s.shade2 *= baseColorMap.rgb;\n    #endif\n  #endif\n  s.baseColor = baseColor;\n  s.baseColor.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.baseColor.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, v_uv).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * emissiveScaleAndStrenth.w) * normalize(v_tangent) +\n      (nmmp.y * emissiveScaleAndStrenth.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  s.specular = specular;\n  #if USE_SPECULAR_MAP\n    s.specular.rgb *= SRGBToLinear(texture(specularMap, v_uv).rgb);\n  #endif\n  s.emissive = emissive.rgb * emissiveScaleAndStrenth.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, v_uv).rgb);\n  #endif\n  s.baseStep = shadeParams.x;\n  s.baseFeather = shadeParams.y;\n  s.shadeStep = shadeParams.z;\n  s.shadeFeather = shadeParams.w;\n}\nvec4 frag () {\n  ToonSurface s; surf(s);\n  vec4 color = CCToonShading(s);\n  return CCFragOutput(color);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 baseColor;\n  vec4 colorScaleAndCutoff;\n  vec4 shadeColor1;\n  vec4 shadeColor2;\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n#endif\nout vec3 v_position;\nout vec2 v_uv;\nout vec3 v_normal;\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  v_normal = (matWorldIT * vec4(In.normal, 0.0)).xyz;\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nstruct ToonSurface {\n  vec4 baseColor;\n  vec4 specular;\n  vec3 position;\n  vec3 normal;\n  vec3 shade1;\n  vec3 shade2;\n  vec3 emissive;\n  float baseStep;\n  float baseFeather;\n  float shadeStep;\n  float shadeFeather;\n};\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  layout(std140) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  vec4 CCToonShading (ToonSurface s) {\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    vec3 N = normalize(s.normal);\n    float specularWeight = 1.0 - pow(s.specular.a, 5.0);\n    vec3 finalColor = vec3(0.0);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = 0.5 * dot(N, SL) + 0.5;\n      float SNH = 0.5 * dot(N, SH) + 0.5;\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr , distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 diffuse = mix(s.shade1, s.shade2,\n        clamp(1.0 + (s.shadeStep - s.shadeFeather - SNL) / s.shadeFeather, 0.0, 1.0));\n      diffuse = mix(s.baseColor.rgb, diffuse,\n        clamp(1.0 + (s.baseStep - s.baseFeather - SNL) / s.baseFeather, 0.0, 1.0));\n      float specularMask = step(specularWeight, SNH);\n      vec3 specular = s.specular.rgb * specularMask;\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      finalColor += SNL * cc_lightColor[i].rgb * cc_lightColor[i].a * illum * att * s.baseStep * (diffuse + specular);\n    }\n    return vec4(finalColor, 0.0);\n  }\n#else\n  #if CC_RECEIVE_SHADOW\n    in highp vec4 v_shadowPos;\n    layout(std140) uniform CCShadow {\n      highp mat4 cc_matLightPlaneProj;\n      highp mat4 cc_matLightView;\n      highp mat4 cc_matLightViewProj;\n      lowp  vec4 cc_shadowNFLSInfo;\n      lowp  vec4 cc_shadowWHPBInfo;\n      lowp  vec4 cc_shadowLPNNInfo;\n      lowp  vec4 cc_shadowColor;\n    };\n    #if CC_RECEIVE_SHADOW\n      uniform sampler2D cc_shadowMap;\n      uniform sampler2D cc_spotLightingMap;\n      float CCGetShadowFactorX1 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float shadow = 0.0;\n        float closestDepth = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n        } else {\n          closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n        }\n        shadow = step(closestDepth, clipPos.z- cc_shadowWHPBInfo.w);\n        return shadow;\n      }\n      float CCGetShadowFactorX5 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n        float offsety = 1.0 / cc_shadowWHPBInfo.y;\n        float shadow = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          float closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        } else {\n          float closestDepth = texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        }\n        return shadow / 5.0;\n      }\n      float CCGetShadowFactorX9 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n        float offsety = 1.0 / cc_shadowWHPBInfo.y;\n        float shadow = 0.0;\n        float closestDepth = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          for (int i = -1; i <= 1; i++) {\n              for (int j = -1; j <= 1; j++) {\n                float closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n                shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n              }\n          }\n        } else {\n          for (int i = -1; i <= 1; i++) {\n              for (int j = -1; j <= 1; j++) {\n                float closestDepth = texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n                shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n              }\n          }\n        }\n        return shadow / 9.0;\n      }\n      float CCGetShadowFactorX25 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n        float offsety = 1.0 / cc_shadowWHPBInfo.y;\n        float shadow = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          for (int i = -2; i <= 2; i++) {\n            for (int j = -2; j <= 2; j++) {\n              float closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n              shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n            }\n          }\n        } else {\n          for (int i = -2; i <= 2; i++) {\n            for (int j = -2; j <= 2; j++) {\n              float closestDepth = texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n              shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n            }\n          }\n        }\n        return shadow / 25.0;\n      }\n    #endif\n  #endif\n  vec4 CCToonShading (ToonSurface s) {\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    vec3 N = normalize(s.normal);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    float NL = 0.5 * dot(N, L) + 0.5;\n    float NH = 0.5 * dot(normalize(V + L), N) + 0.5;\n    vec3 lightColor = cc_mainLitColor.rgb * cc_mainLitColor.w * s.baseStep;\n    vec3 diffuse = mix(s.shade1, s.shade2,\n      clamp(1.0 + (s.shadeStep - s.shadeFeather - NL) / s.shadeFeather, 0.0, 1.0));\n    diffuse = mix(s.baseColor.rgb, diffuse,\n      clamp(1.0 + (s.baseStep - s.baseFeather - NL) / s.baseFeather, 0.0, 1.0));\n    float specularWeight = 1.0 - pow(s.specular.a, 5.0);\n    float specularMask = step(specularWeight, NH);\n    vec3 specular = s.specular.rgb * specularMask;\n    vec3 finalColor = lightColor * (diffuse + specular);\n    #if CC_USE_HDR\n      s.emissive *= cc_exposure.w;\n    #endif\n    finalColor += s.emissive;\n    #if CC_RECEIVE_SHADOW\n              {\n                float pcf = cc_shadowWHPBInfo.z + 0.001;\n                float shadowAttenuation = 0.0;\n                float cosAngle = clamp(1.0 - dot(N, cc_mainLitDir.xyz), 0.0, 1.0);\n                vec3 projWorldPos = v_shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\n                vec4 pos = vec4(projWorldPos.xyz, v_shadowPos.w);\n                if (pcf > 3.0) shadowAttenuation = CCGetShadowFactorX25(pos);\n                else if (pcf > 2.0) shadowAttenuation = CCGetShadowFactorX9(pos);\n                else if (pcf > 1.0) shadowAttenuation = CCGetShadowFactorX5(pos);\n                else shadowAttenuation = CCGetShadowFactorX1(pos);\n                vec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + finalColor.rgb * (1.0 - cc_shadowColor.a);\n                if (cc_shadowNFLSInfo.w > 0.000001) {\n                  finalColor.rgb = shadowColor.rgb * shadowAttenuation + finalColor.rgb * (1.0 - shadowAttenuation);\n                } else {\n                  finalColor.rgb = shadowColor.rgb * shadowAttenuation * NL + finalColor.rgb * (1.0 - shadowAttenuation * NL);\n                }\n              }\n    #endif\n    return vec4(finalColor, s.baseColor.a);\n  }\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 baseColor;\n  vec4 colorScaleAndCutoff;\n  vec4 shadeColor1;\n  vec4 shadeColor2;\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nin vec3 v_position;\nin vec2 v_uv;\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\nin vec3 v_normal;\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_1ST_SHADE_MAP\n  uniform sampler2D shadeMap1;\n#endif\n#if USE_2ND_SHADE_MAP\n  uniform sampler2D shadeMap2;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out ToonSurface s) {\n  s.shade2 = shadeColor2.rgb * colorScaleAndCutoff.rgb;\n  #if USE_2ND_SHADE_MAP\n    s.shade2 *= SRGBToLinear(texture(shadeMap2, v_uv).rgb);\n  #endif\n  s.shade1 = shadeColor1.rgb * colorScaleAndCutoff.rgb;\n  #if USE_1ST_SHADE_MAP\n    s.shade1 *= SRGBToLinear(texture(shadeMap1, v_uv).rgb);\n    #if SHADE_MAP_1_AS_SHADE_MAP_2\n      s.shade2 *= s.shade1.rgb;\n    #endif\n  #endif\n  vec4 baseColor = baseColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 baseColorMap = texture(baseColorMap, v_uv);\n    baseColorMap.rgb = SRGBToLinear(baseColorMap.rgb);\n    baseColor *= baseColorMap;\n    #if BASE_COLOR_MAP_AS_SHADE_MAP_1\n      s.shade1 *= baseColorMap.rgb;\n    #endif\n    #if BASE_COLOR_MAP_AS_SHADE_MAP_2\n      s.shade2 *= baseColorMap.rgb;\n    #endif\n  #endif\n  s.baseColor = baseColor;\n  s.baseColor.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.baseColor.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, v_uv).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * emissiveScaleAndStrenth.w) * normalize(v_tangent) +\n      (nmmp.y * emissiveScaleAndStrenth.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  s.specular = specular;\n  #if USE_SPECULAR_MAP\n    s.specular.rgb *= SRGBToLinear(texture(specularMap, v_uv).rgb);\n  #endif\n  s.emissive = emissive.rgb * emissiveScaleAndStrenth.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, v_uv).rgb);\n  #endif\n  s.baseStep = shadeParams.x;\n  s.baseFeather = shadeParams.y;\n  s.shadeStep = shadeParams.z;\n  s.shadeFeather = shadeParams.w;\n}\nvec4 frag () {\n  ToonSurface s; surf(s);\n  vec4 color = CCToonShading(s);\n  return CCFragOutput(color);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\n      uniform vec4 tilingOffset;\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec3 v_normal;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  v_normal = (matWorldIT * vec4(In.normal, 0.0)).xyz;\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nuniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_exposure;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\nstruct ToonSurface {\n  vec4 baseColor;\n  vec4 specular;\n  vec3 position;\n  vec3 normal;\n  vec3 shade1;\n  vec3 shade2;\n  vec3 emissive;\n  float baseStep;\n  float baseFeather;\n  float shadeStep;\n  float shadeFeather;\n};\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  vec4 CCToonShading (ToonSurface s) {\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    vec3 N = normalize(s.normal);\n    float specularWeight = 1.0 - pow(s.specular.a, 5.0);\n    vec3 finalColor = vec3(0.0);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = 0.5 * dot(N, SL) + 0.5;\n      float SNH = 0.5 * dot(N, SH) + 0.5;\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr , distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 diffuse = mix(s.shade1, s.shade2,\n        clamp(1.0 + (s.shadeStep - s.shadeFeather - SNL) / s.shadeFeather, 0.0, 1.0));\n      diffuse = mix(s.baseColor.rgb, diffuse,\n        clamp(1.0 + (s.baseStep - s.baseFeather - SNL) / s.baseFeather, 0.0, 1.0));\n      float specularMask = step(specularWeight, SNH);\n      vec3 specular = s.specular.rgb * specularMask;\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      finalColor += SNL * cc_lightColor[i].rgb * cc_lightColor[i].a * illum * att * s.baseStep * (diffuse + specular);\n    }\n    return vec4(finalColor, 0.0);\n  }\n#else\n  #if CC_RECEIVE_SHADOW\n    varying highp vec4 v_shadowPos;\n    uniform lowp vec4 cc_shadowNFLSInfo;\n  uniform lowp vec4 cc_shadowWHPBInfo;\n  uniform lowp vec4 cc_shadowLPNNInfo;\n  uniform lowp vec4 cc_shadowColor;\n    #if CC_RECEIVE_SHADOW\n      uniform sampler2D cc_shadowMap;\n      uniform sampler2D cc_spotLightingMap;\n      float CCGetShadowFactorX1 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float shadow = 0.0;\n        float closestDepth = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n        } else {\n          closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n        }\n        shadow = step(closestDepth, clipPos.z- cc_shadowWHPBInfo.w);\n        return shadow;\n      }\n      float CCGetShadowFactorX5 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n        float offsety = 1.0 / cc_shadowWHPBInfo.y;\n        float shadow = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          float closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        } else {\n          float closestDepth = texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        }\n        return shadow / 5.0;\n      }\n      float CCGetShadowFactorX9 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n        float offsety = 1.0 / cc_shadowWHPBInfo.y;\n        float shadow = 0.0;\n        float closestDepth = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          for (int i = -1; i <= 1; i++) {\n              for (int j = -1; j <= 1; j++) {\n                float closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n                shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n              }\n          }\n        } else {\n          for (int i = -1; i <= 1; i++) {\n              for (int j = -1; j <= 1; j++) {\n                float closestDepth = texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n                shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n              }\n          }\n        }\n        return shadow / 9.0;\n      }\n      float CCGetShadowFactorX25 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n        float offsety = 1.0 / cc_shadowWHPBInfo.y;\n        float shadow = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          for (int i = -2; i <= 2; i++) {\n            for (int j = -2; j <= 2; j++) {\n              float closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n              shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n            }\n          }\n        } else {\n          for (int i = -2; i <= 2; i++) {\n            for (int j = -2; j <= 2; j++) {\n              float closestDepth = texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n              shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n            }\n          }\n        }\n        return shadow / 25.0;\n      }\n    #endif\n  #endif\n  vec4 CCToonShading (ToonSurface s) {\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    vec3 N = normalize(s.normal);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    float NL = 0.5 * dot(N, L) + 0.5;\n    float NH = 0.5 * dot(normalize(V + L), N) + 0.5;\n    vec3 lightColor = cc_mainLitColor.rgb * cc_mainLitColor.w * s.baseStep;\n    vec3 diffuse = mix(s.shade1, s.shade2,\n      clamp(1.0 + (s.shadeStep - s.shadeFeather - NL) / s.shadeFeather, 0.0, 1.0));\n    diffuse = mix(s.baseColor.rgb, diffuse,\n      clamp(1.0 + (s.baseStep - s.baseFeather - NL) / s.baseFeather, 0.0, 1.0));\n    float specularWeight = 1.0 - pow(s.specular.a, 5.0);\n    float specularMask = step(specularWeight, NH);\n    vec3 specular = s.specular.rgb * specularMask;\n    vec3 finalColor = lightColor * (diffuse + specular);\n    #if CC_USE_HDR\n      s.emissive *= cc_exposure.w;\n    #endif\n    finalColor += s.emissive;\n    #if CC_RECEIVE_SHADOW\n              {\n                float pcf = cc_shadowWHPBInfo.z + 0.001;\n                float shadowAttenuation = 0.0;\n                float cosAngle = clamp(1.0 - dot(N, cc_mainLitDir.xyz), 0.0, 1.0);\n                vec3 projWorldPos = v_shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\n                vec4 pos = vec4(projWorldPos.xyz, v_shadowPos.w);\n                if (pcf > 3.0) shadowAttenuation = CCGetShadowFactorX25(pos);\n                else if (pcf > 2.0) shadowAttenuation = CCGetShadowFactorX9(pos);\n                else if (pcf > 1.0) shadowAttenuation = CCGetShadowFactorX5(pos);\n                else shadowAttenuation = CCGetShadowFactorX1(pos);\n                vec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + finalColor.rgb * (1.0 - cc_shadowColor.a);\n                if (cc_shadowNFLSInfo.w > 0.000001) {\n                  finalColor.rgb = shadowColor.rgb * shadowAttenuation + finalColor.rgb * (1.0 - shadowAttenuation);\n                } else {\n                  finalColor.rgb = shadowColor.rgb * shadowAttenuation * NL + finalColor.rgb * (1.0 - shadowAttenuation * NL);\n                }\n              }\n    #endif\n    return vec4(finalColor, s.baseColor.a);\n  }\n#endif\n    uniform vec4 baseColor;\n    uniform vec4 colorScaleAndCutoff;\n    uniform vec4 shadeColor1;\n    uniform vec4 shadeColor2;\n    uniform vec4 specular;\n    uniform vec4 shadeParams;\n    uniform vec4 emissive;\n    uniform vec4 emissiveScaleAndStrenth;\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nvarying vec3 v_position;\nvarying vec2 v_uv;\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\nvarying vec3 v_normal;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_1ST_SHADE_MAP\n  uniform sampler2D shadeMap1;\n#endif\n#if USE_2ND_SHADE_MAP\n  uniform sampler2D shadeMap2;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out ToonSurface s) {\n  s.shade2 = shadeColor2.rgb * colorScaleAndCutoff.rgb;\n  #if USE_2ND_SHADE_MAP\n    s.shade2 *= SRGBToLinear(texture2D(shadeMap2, v_uv).rgb);\n  #endif\n  s.shade1 = shadeColor1.rgb * colorScaleAndCutoff.rgb;\n  #if USE_1ST_SHADE_MAP\n    s.shade1 *= SRGBToLinear(texture2D(shadeMap1, v_uv).rgb);\n    #if SHADE_MAP_1_AS_SHADE_MAP_2\n      s.shade2 *= s.shade1.rgb;\n    #endif\n  #endif\n  vec4 baseColor = baseColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 baseColorMap = texture2D(baseColorMap, v_uv);\n    baseColorMap.rgb = SRGBToLinear(baseColorMap.rgb);\n    baseColor *= baseColorMap;\n    #if BASE_COLOR_MAP_AS_SHADE_MAP_1\n      s.shade1 *= baseColorMap.rgb;\n    #endif\n    #if BASE_COLOR_MAP_AS_SHADE_MAP_2\n      s.shade2 *= baseColorMap.rgb;\n    #endif\n  #endif\n  s.baseColor = baseColor;\n  s.baseColor.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.baseColor.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, v_uv).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * emissiveScaleAndStrenth.w) * normalize(v_tangent) +\n      (nmmp.y * emissiveScaleAndStrenth.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  s.specular = specular;\n  #if USE_SPECULAR_MAP\n    s.specular.rgb *= SRGBToLinear(texture2D(specularMap, v_uv).rgb);\n  #endif\n  s.emissive = emissive.rgb * emissiveScaleAndStrenth.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture2D(emissiveMap, v_uv).rgb);\n  #endif\n  s.baseStep = shadeParams.x;\n  s.baseFeather = shadeParams.y;\n  s.shadeStep = shadeParams.z;\n  s.shadeFeather = shadeParams.w;\n}\nvec4 frag () {\n  ToonSurface s; surf(s);\n  vec4 color = CCToonShading(s);\n  return CCFragOutput(color);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]}]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":219,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":62}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"USE_NORMAL_MAP","type":"boolean","defines":[]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"CC_PIPELINE_TYPE","type":"number","defines":["CC_FORWARD_ADD"],"range":[0,1]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_BASE_COLOR_MAP","type":"boolean","defines":[]},{"name":"USE_1ST_SHADE_MAP","type":"boolean","defines":[]},{"name":"USE_2ND_SHADE_MAP","type":"boolean","defines":[]},{"name":"USE_SPECULAR_MAP","type":"boolean","defines":[]},{"name":"USE_EMISSIVE_MAP","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r","g","b"]},{"name":"SHADE_MAP_1_AS_SHADE_MAP_2","type":"boolean","defines":["USE_1ST_SHADE_MAP"]},{"name":"BASE_COLOR_MAP_AS_SHADE_MAP_1","type":"boolean","defines":["USE_BASE_COLOR_MAP"]},{"name":"BASE_COLOR_MAP_AS_SHADE_MAP_2","type":"boolean","defines":["USE_BASE_COLOR_MAP"]}],"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"baseColor","type":16,"count":1},{"name":"colorScaleAndCutoff","type":16,"count":1},{"name":"shadeColor1","type":16,"count":1},{"name":"shadeColor2","type":16,"count":1},{"name":"specular","type":16,"count":1},{"name":"shadeParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleAndStrenth","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"baseColorMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_BASE_COLOR_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"shadeMap1","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_1ST_SHADE_MAP"]},{"name":"shadeMap2","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_2ND_SHADE_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_SPECULAR_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_EMISSIVE_MAP"]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord","type":14,"count":1,"stageFlags":1,"format":21,"location":2,"defines":[]},{"name":"a_tangent","type":16,"count":1,"stageFlags":1,"format":44,"location":3,"defines":[]},{"name":"a_vertexId","type":13,"count":1,"stageFlags":1,"format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","type":"u32vec4","count":1,"stageFlags":1,"location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","type":16,"count":1,"stageFlags":1,"format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","type":13,"count":1,"stageFlags":1,"format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]}],"varyings":[{"name":"v_shadowPos","type":16,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"v_position","type":15,"count":1,"stageFlags":1,"location":1,"defines":[]},{"name":"v_uv","type":14,"count":1,"stageFlags":1,"location":2,"defines":[]},{"name":"v_normal","type":15,"count":1,"stageFlags":1,"location":3,"defines":[]},{"name":"v_tangent","type":15,"count":1,"stageFlags":1,"location":4,"defines":["USE_NORMAL_MAP"]},{"name":"v_bitangent","type":15,"count":1,"stageFlags":1,"location":5,"defines":["USE_NORMAL_MAP"]}]},{"hash":1991198131,"name":"builtin-toon|shadow-caster-vs:vert|shadow-caster-fs:frag","glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 baseColor;\n  vec4 colorScaleAndCutoff;\n  vec4 shadeColor1;\n  vec4 shadeColor2;\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\nlayout(location = 0) out vec2 v_uv;\nlayout(location = 1) out vec2 v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  v_clip_depth = clipPos.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 baseColor;\n  vec4 colorScaleAndCutoff;\n  vec4 shadeColor1;\n  vec4 shadeColor2;\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n  ret = fract(ret);\n  ret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return ret;\n}\nlayout(location = 0) in vec2 v_uv;\nlayout(location = 1) in vec2 v_clip_depth;\n#if USE_BASE_COLOR_MAP\n  layout(set = 1, binding = 1) uniform sampler2D baseColorMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = baseColor;\n  #if USE_BASE_COLOR_MAP\n    baseColor *= texture(baseColorMap, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  return packDepthToRGBA(v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 baseColor;\n  vec4 colorScaleAndCutoff;\n  vec4 shadeColor1;\n  vec4 shadeColor2;\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\nout vec2 v_uv;\nout vec2 v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  v_clip_depth = clipPos.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 baseColor;\n  vec4 colorScaleAndCutoff;\n  vec4 shadeColor1;\n  vec4 shadeColor2;\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n  ret = fract(ret);\n  ret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return ret;\n}\nin vec2 v_uv;\nin vec2 v_clip_depth;\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = baseColor;\n  #if USE_BASE_COLOR_MAP\n    baseColor *= texture(baseColorMap, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  return packDepthToRGBA(v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\n      uniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\nvarying vec2 v_uv;\nvarying vec2 v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  v_clip_depth = clipPos.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n   uniform vec4 baseColor;\n   uniform vec4 colorScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n  ret = fract(ret);\n  ret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return ret;\n}\nvarying vec2 v_uv;\nvarying vec2 v_clip_depth;\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = baseColor;\n  #if USE_BASE_COLOR_MAP\n    baseColor *= texture2D(baseColorMap, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  return packDepthToRGBA(v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]}],"samplerTextures":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":182,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":9}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"USE_BASE_COLOR_MAP","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r","g","b"]}],"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"baseColor","type":16,"count":1},{"name":"colorScaleAndCutoff","type":16,"count":1},{"name":"shadeColor1","type":16,"count":1},{"name":"shadeColor2","type":16,"count":1},{"name":"specular","type":16,"count":1},{"name":"shadeParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleAndStrenth","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"baseColorMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_BASE_COLOR_MAP"]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord","type":14,"count":1,"stageFlags":1,"format":21,"location":2,"defines":[]},{"name":"a_tangent","type":16,"count":1,"stageFlags":1,"format":44,"location":3,"defines":[]},{"name":"a_vertexId","type":13,"count":1,"stageFlags":1,"format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","type":"u32vec4","count":1,"stageFlags":1,"location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","type":16,"count":1,"stageFlags":1,"format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","type":13,"count":1,"stageFlags":1,"format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"v_clip_depth","type":14,"count":1,"stageFlags":1,"location":1,"defines":[]}]}],[{"passes":[{"program":"builtin-toon|outline-vs:vert|outline-fs:frag","switch":"USE_OUTLINE_PASS","rasterizerState":{"cullMode":1},"properties":{"lineWidth":{"type":13,"value":[10],"handleInfo":["outlineParams",0,13]},"depthBias":{"type":13,"value":[0],"handleInfo":["outlineParams",1,13]},"baseColor":{"type":16,"editor":{"type":"color"}},"baseColorMap":{"value":"grey","type":28},"outlineParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[10,0,0,0]}}},{"program":"builtin-toon|toon-vs:vert|toon-fs:frag","properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[0.6,0.6,0.6,1],"editor":{"displayName":"BaseColor","type":"color"},"handleInfo":["baseColor",0,16]},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"shadeColor1":{"type":16,"value":[0.4,0.4,0.4,1],"editor":{"type":"color"}},"shadeColor2":{"type":16,"value":[0.2,0.2,0.2,1],"editor":{"type":"color"}},"specular":{"type":16,"value":[1,1,1,0.3],"editor":{"type":"color"}},"baseStep":{"type":13,"value":[0.8],"handleInfo":["shadeParams",0,13]},"baseFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",1,13]},"shadeStep":{"type":13,"value":[0.5],"handleInfo":["shadeParams",2,13]},"shadeFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleAndStrenth",0,15]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP"},"handleInfo":["emissiveScaleAndStrenth",3,13]},"normalMap":{"value":"normal","type":28},"mainTexture":{"value":"white","type":28,"editor":{"displayName":"BaseColorMap"},"handleInfo":["baseColorMap",0,28]},"shadeMap1":{"value":"white","type":28},"shadeMap2":{"value":"white","type":28},"specularMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"baseColor":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.6,0.6,0.6,1]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"shadeParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.8,0.001,0.5,0.001]},"emissiveScaleAndStrenth":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"baseColorMap":{"type":28,"value":"white","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":1,"program":"builtin-toon|toon-vs:vert|toon-fs:frag","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[0.6,0.6,0.6,1],"editor":{"displayName":"BaseColor","type":"color"},"handleInfo":["baseColor",0,16]},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"shadeColor1":{"type":16,"value":[0.4,0.4,0.4,1],"editor":{"type":"color"}},"shadeColor2":{"type":16,"value":[0.2,0.2,0.2,1],"editor":{"type":"color"}},"specular":{"type":16,"value":[1,1,1,0.3],"editor":{"type":"color"}},"baseStep":{"type":13,"value":[0.8],"handleInfo":["shadeParams",0,13]},"baseFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",1,13]},"shadeStep":{"type":13,"value":[0.5],"handleInfo":["shadeParams",2,13]},"shadeFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleAndStrenth",0,15]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP"},"handleInfo":["emissiveScaleAndStrenth",3,13]},"normalMap":{"value":"normal","type":28},"mainTexture":{"value":"white","type":28,"editor":{"displayName":"BaseColorMap"},"handleInfo":["baseColorMap",0,28]},"shadeMap1":{"value":"white","type":28},"shadeMap2":{"value":"white","type":28},"specularMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"baseColor":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.6,0.6,0.6,1]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"shadeParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.8,0.001,0.5,0.001]},"emissiveScaleAndStrenth":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"baseColorMap":{"type":28,"value":"white","editor":{"visible":false,"deprecated":true}}}},{"phase":"shadow-caster","propertyIndex":1,"program":"builtin-toon|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[0.6,0.6,0.6,1],"editor":{"displayName":"BaseColor","type":"color"},"handleInfo":["baseColor",0,16]},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"shadeColor1":{"type":16,"value":[0.4,0.4,0.4,1],"editor":{"type":"color"}},"shadeColor2":{"type":16,"value":[0.2,0.2,0.2,1],"editor":{"type":"color"}},"specular":{"type":16,"value":[1,1,1,0.3],"editor":{"type":"color"}},"baseStep":{"type":13,"value":[0.8],"handleInfo":["shadeParams",0,13]},"baseFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",1,13]},"shadeStep":{"type":13,"value":[0.5],"handleInfo":["shadeParams",2,13]},"shadeFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleAndStrenth",0,15]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP"},"handleInfo":["emissiveScaleAndStrenth",3,13]},"mainTexture":{"value":"white","type":28,"editor":{"displayName":"BaseColorMap"},"handleInfo":["baseColorMap",0,28]},"baseColor":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.6,0.6,0.6,1]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"shadeParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.8,0.001,0.5,0.001]},"emissiveScaleAndStrenth":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"baseColorMap":{"type":28,"value":"white","editor":{"visible":false,"deprecated":true}}}}]}]]],0,0,[],[],[]],[[[23,"Skin-0",753820634,["RootNode/Bone004/Bone005/Bone006","RootNode/Bone004/Bone005","RootNode/Bone004","RootNode/Bone001/Bone002/Bone003","RootNode/Bone001/Bone002","RootNode/Bone001"],[[[7,0.0004333891556598246,0.10229005664587021,0.21936364471912384,0,-0.0009294628980569541,-0.21936167776584625,0.10229097306728363,0,0.24203883111476898,-0.0010255376109853387,2.406476085070608e-8,0,-0.08006425946950912,0.028319520875811577,-0.005389618221670389,1],[7,0.0006473671528510749,0.10228893905878067,0.21936364471912384,0,-0.001388339907862246,-0.21935929358005524,0.10229097306728363,0,0.24203617870807648,-0.0015318524092435837,2.4064471304541257e-8,0,-0.04029082506895065,0.0284869447350502,-0.005389610305428505,1],[7,-0.0006353461649268866,0.10228794068098068,0.21936413645744324,0,0.0013624817365780473,-0.21935993432998657,0.10228990018367767,0,0.2420363426208496,0.0015033365925773978,1.664581716909197e-8,0,-0.0001784319174475968,0.02797948755323887,-0.0053894720040261745,1],[7,0.0004333891556598246,0.10229005664587021,0.21936364471912384,0,-0.0009294628980569541,-0.21936167776584625,0.10229097306728363,0,0.24203883111476898,-0.0010255376109853387,2.406476085070608e-8,0,-0.08025984466075897,-0.017842883244156837,0.01121316384524107,1],[7,0.0006473671528510749,0.10228893905878067,0.21936364471912384,0,-0.001388339907862246,-0.21935929358005524,0.10229097306728363,0,0.24203617870807648,-0.0015318524092435837,2.4064471304541257e-8,0,-0.040582988411188126,-0.017674952745437622,0.011213171295821667,1],[7,-0.0006353461649268866,0.10228794068098068,0.21936413645744324,0,0.0013624817365780473,-0.21935993432998657,0.10228990018367767,0,0.2420363426208496,0.0015033365925773978,1.664581716909197e-8,0,0.00010828844096977264,-0.01818251982331276,0.011213085614144802,1]],8,8,8,8,8,8]]],0,0,[],[],[]],[[[33,"Take 001",".bin",30,2,true,3.3333332538604736,1114036689,[[1,8000,81,6,81]],[[[{},"modifiers",12,[[-1,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[34,324,38,81]]],[{},"modifiers",12,[[-2,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,1296,3,22,1]]],[{},"modifiers",12,[[-3,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,1308,3,22,1]]],[{},"modifiers",12,[[-4,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[1,1320,324,38,81]]],[{},"modifiers",12,[[-5,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,2616,3,22,1]]],[{},"modifiers",12,[[-6,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,2628,3,22,1]]],[{},"modifiers",12,[[-7,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[1,2640,324,38,81]]],[{},"modifiers",12,[[-8,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,3936,3,22,1]]],[{},"modifiers",12,[[-9,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,3948,3,22,1]]],[{},"modifiers",12,[[-10,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[1,3960,324,38,81]]],[{},"modifiers",12,[[-11,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,5256,3,22,1]]],[{},"modifiers",12,[[-12,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,5268,3,22,1]]],[{},"modifiers",12,[[-13,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[1,5280,324,38,81]]],[{},"modifiers",12,[[-14,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,6576,3,22,1]]],[{},"modifiers",12,[[-15,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,6588,3,22,1]]],[{},"modifiers",12,[[-16,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[1,6600,324,38,81]]],[{},"modifiers",12,[[-17,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,7896,3,22,1]]],[{},"modifiers",12,[[-18,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,7908,3,22,1]]],[{},"modifiers",12,[[-19,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,7920,3,22,1]]],[{},"modifiers",12,[[-20,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,7932,3,22,1]]],[{},"modifiers",12,[[-21,"rotation"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,7944,4,38,1]]],[{},"modifiers",12,[[-22,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,7960,3,22,1]]],[{},"modifiers",12,[[-23,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,7972,3,22,1]]],[{},"modifiers",12,[[-24,"rotation"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,7984,4,38,1]]]],11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11]],[4,"RootNode/Bone001"],[4,"RootNode/Bone001/Bone002"],[4,"RootNode/Bone001/Bone002/Bone003"],[4,"RootNode/Bone004"],[4,"RootNode/Bone004/Bone005"],[4,"RootNode/Bone004/Bone005/Bone006"],[4,"RootNode"],[4,"RootNode/grass"]],0,[0,-1,1,0,-1,1,0,-1,1,0,-1,2,0,-1,2,0,-1,2,0,-1,3,0,-1,3,0,-1,3,0,-1,4,0,-1,4,0,-1,4,0,-1,5,0,-1,5,0,-1,5,0,-1,6,0,-1,6,0,-1,6,0,-1,7,0,-1,7,0,-1,7,0,-1,8,0,-1,8,0,-1,8,24],[],[],[]],[[[12,".bin",8542,3275415776,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":8080,"length":462,"count":231,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":8080,"count":101,"stride":80},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5]]},"minPosition",8,[1,-0.23816974461078644,-0.3651643395423889,-0.02080436609685421],"maxPosition",8,[1,0.2359408587217331,0.26479941606521606,0.6728445887565613]]]],0,0,[],[],[]],[[[22,[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],[{"USE_TEXTURE":true}],[[[{"alphaThreshold":0},"mainTexture",6,0]],11]]],0,0,[0,0],[6,7],[18,19]],[[[24,"islands"],[28,"islands",[-2],[0,"26LvC5hbxAuJZ9Jl2SB/IV",-1,0]],[14,"RootNode",1,[-3,-4,-5,-6,-7,-8,-9,-10,-11,-12],[0,"068WXOAs1HrIDx+RBQ6XoV",1,0]],[10,"plane01",2,[[35,-13,[5,"ddvMFij+ZIL5lu+/NQX8Nf"],[0],[3],1]],[0,"70dgNwYARPfbvgVcNs+gIQ",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,4.25968408584595,4.25968408584595,2.35247683525085],[1,-90.00000000000003,0,0]],[38,"stone1",2,[[21,1,-14,[5,"e3XMjUJKFLH41z39JaWzyB"],[2],[3],3]],[0,"fd517lz3tOuqVWGd5300X6",1,0],[1,-1.68451106548309,0.804959058761597,-2.55509376525879],[1,0.111417099833488,0.111417099833488,0.111417099833488],[1,0.000009334667642611398,0,0]],[20,"tree1",2,[[35,-15,[5,"a5Viy6l3VLDpf6gY5yZF+v"],[4],[3],5]],[0,"1evO3wfhhGVomhJPkvbiM/",1,0],[1,2.69967889785767,0.392187118530273,-3.67192149162292],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-90.00000000000003,0,0]],[20,"tree1(__autogen 3)",2,[[21,1,-16,[5,"e4If/bQrJCsb9D9JopZa2h"],[6],[3],7]],[0,"91DpAWXZ9CFJ+Wk1gnOU27",1,0],[1,4.34285020828247,0.273025780916214,-4.5796275138855],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-90.00000000000003,0,0]],[20,"tree1(__autogen 4)",2,[[21,1,-17,[5,"d7Vkz0NV5Mn4RUce28JVTp"],[8],[3],9]],[0,"03YnQPZo5Nc7TYZfZ1EVIK",1,0],[1,-2.78155946731567,0.366120487451553,-5.44366216659546],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-90.00000000000003,0,0]],[20,"tree1(__autogen 5)",2,[[21,1,-18,[5,"3eVATgLQJKDbqOvE33W2uc"],[10],[3],11]],[0,"aehmnp6BdEt5duOREy07Ic",1,0],[1,-3.78196001052856,0.328564822673798,-3.62895131111145],[3,-0.7071067811865447,-6.18172403853676e-8,-6.18172403853676e-8,0.7071067811865447],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-89.99999999999999,-0.000010017912624975451,0]],[20,"tree1(__autogen 6)",2,[[21,1,-19,[5,"2akU/MgO5Ovo6QcS0c/I7e"],[12],[3],13]],[0,"1dXVprqA1AkpKbrdcroE4U",1,0],[1,-6.02857780456543,0.0573978498578072,-3.32550001144409],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-90.00000000000003,0,0]],[20,"tree1(__autogen 7)",2,[[21,1,-20,[5,"54xaKIQbtPLK5r21VY0qmM"],[14],[3],15]],[0,"c2n9MRvPxJRbv1PP2mhkZO",1,0],[1,-0.547172009944916,0.595235526561737,-3.40697646141052],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-90.00000000000003,0,0]],[20,"tree1(__autogen 8)",2,[[21,1,-21,[5,"23UFBqszxJ/6Otof04QwYT"],[16],[3],17]],[0,"e7VpTFkQ1Ev40vpNxYe7EG",1,0],[1,-6.58904409408569,0.117208734154701,-1.02060234546661],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-90.00000000000003,0,0]],[20,"tree1(__autogen 9)",2,[[21,1,-22,[5,"c7PE6gNTdDw45ytwlOEWR3"],[18],[3],19]],[0,"a1wQefYUNInYWhsOmPzInv",1,0],[1,5.92053079605103,0.1805190294981,-2.71322011947632],[3,-0.7071067811865447,-6.18172403853676e-8,-6.18172403853676e-8,0.7071067811865447],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-89.99999999999999,-0.000010017912624975451,0]]],0,[0,5,1,0,-1,2,0,-1,3,0,-2,4,0,-3,5,0,-4,6,0,-5,7,0,-6,8,0,-7,9,0,-8,10,0,-9,11,0,-10,12,0,0,3,0,0,4,0,0,5,0,0,6,0,0,7,0,0,8,0,0,9,0,0,10,0,0,11,0,0,12,0,8,1,22],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2],[20,21,22,23,4,24,4,25,4,26,4,27,4,28,4,29,4,30,4,31]],[[[24,"soldier"],[39,"soldier",[-3],[[26,true,-2,[5,"04W3Kzvb9BZbZUGFZzfzi5"],[12],13]],[0,"6dMvPN2t1B66O9Zc3HG8dr",-1,0],[1,0,0.956,1.402]],[14,"RootNode",1,[-4,-5,-6,-7,-8],[0,"a5uiqiY3JH2IVaNOBBe7fQ",1,0]],[40,"Bip001 Spine",[-9,-10,-11],[0,"deedfocu1E0amfQjzHnnD8",1,0],[1,0.0765029862523079,-0.000119566058856435,1.06260117149759e-7],[3,-0.000002080475910607327,-6.936759723456761e-7,0.0003981589901667568,0.9999999207323014],[1,-0.00023837338537102568,-0.00007939450691674313,0.045625660794268635]],[41,"Bip001 Neck",[-12,-13,-14],[0,"de+U9IqPVD+qUUY0y7H/86",1,0],[1,0.15020164847374,-0.0000435724105045665,-1.20852522433879e-10]],[45,"Bip001",2,[[[7,"Bip001 Footsteps",-15,[0,"24sP2WouNOyq9Pp+iqRgiX",1,0],[1,-5.16987871290063e-28,0,-0.734457075595856],[3,-6.921034890422563e-34,6.921044533149828e-34,0.7071063043492202,0.7071072580235535],[1,0,-1.1216009582263186e-31,90]],-16],4,1],[0,"15XJ/3651AFKLyr6XRj3d7",1,0],[1,0,0.738336980342865,-3.74271143591121e-12],[3,-0.5000003576277411,-0.4999996423720031,-0.4999996423720031,0.5000003576277411],[1,-90,-89.99991803772988,0]],[10,"soldier",2,[[47,1,-17,[5,"78XZsd31xPjIsSP2888FcN"],[0],[3],1,1,2]],[0,"824q3ldSpHoYl9xi6zWeg4",1,0],[3,0.9999999999999953,0,0,-9.735359185469814e-8],[1,87.7489852905273,87.7489852905273,87.7489852905273],[1,-179.99998884410013,0,0]],[42,"Bip001 Pelvis",5,[3],[0,"9brOPlFAxPnLhkrpP6KbLQ",1,0],[3,-0.4999999925491744,-0.4999999925491744,-0.4999993070957696,0.5000007078049007],[1,-89.9999197452773,-89.9999197452773,-0.0000017074910412130916]],[16,"Bip001 L Thigh",3,[-18],[0,"4aENadJ59Io4SS6BMn9Aw4",1,0],[1,-0.0765029117465019,0.000180334449396469,0.0665242150425911],[3,-0.015412850192755845,0.9969698713847834,0.002043751751963479,-0.07621904406852757],[1,-0.098918034361683,-171.25793904676914,-1.7789668366715101]],[16,"Bip001 L Calf",8,[-19],[0,"71+6ovA8dDUowhlyNGBIbM",1,0],[1,0.368020862340927,-2.38418573772492e-9,1.90734859017994e-8],[3,-3.77253945323161e-21,-4.658679694134547e-18,-0.0008097870399876981,0.999999672122421],[1,-8.646032309262241e-19,-5.338462443351186e-16,-0.09279476953314847]],[16,"Bip001 L Foot",9,[-20],[0,"71/rP0sWxM1bfHuNwls2lv",1,0],[1,0.29802131652832,-2.38418573772492e-9,0],[3,0.0020737143220202685,-0.07621822672483194,0.016616994877612996,0.9969505289155877],[1,0.3822464844159605,-8.749946017824339,1.8805865416881686]],[6,"Bip001 L Toe0",10,[[43,"Bip001 L Toe0Nub",-21,[0,"b7ARhVJWFJP4yiboWbM1Xs",1,0],[1,0.00997863244265318,-2.98023217215615e-10,3.55271359939116e-17],[3,9.55341250274695e-16,-2.4399608215727e-23,1,1.83758927467374e-15],[1,-1,-1,-1],[1,180,-179.9999999999999,2.1057221983462293e-13]]],[0,"b7IX4wc+BII5SOxaDKm4bu",1,0],[1,0.0765028968453407,0.0984558463096619,1.90734859017994e-8],[3,-1.5454308319985125e-8,-1.5454308319985125e-8,0.7071067811865472,0.7071067811865472],[1,0,-0.0000025044778683729224,90]],[16,"Bip001 R Thigh",3,[-22],[0,"baRkxlpMJMup2UzoK3llZt",1,0],[1,-0.0765029117465019,0.000180703471414745,-0.0665242150425911],[3,-0.0154126518850906,0.9969698755273314,-0.0020409899233692465,0.07621910398987286],[1,0.09860398393799301,171.25792731952373,-1.7789200579558455]],[16,"Bip001 R Calf",12,[-23],[0,"8a4oYAyD9MkZi9aL5G15gW",1,0],[1,0.36802089214325,0,-3.55271359939116e-17],[3,2.226103102352033e-19,7.125063520427799e-18,-0.0008097898921612967,0.9999996721201113],[1,2.6170459347986135e-17,8.164935972515574e-16,-0.09279509636827488]],[16,"Bip001 R Foot",13,[-24],[0,"cdWn1utjJOUaNdTLXxb/CR",1,0],[1,0.29802131652832,0,-3.81469718035987e-8],[3,-0.002073778117879438,0.07621821928385913,0.016617013506159614,0.9969505290412618],[1,-0.38225392566993516,8.749945293799216,1.8805881155171484]],[6,"Bip001 R Toe0",14,[[31,"Bip001 R Toe0Nub",-25,[0,"77BI3YwgNJqKMpf0rJhZ9s",1,0],[1,0.00997863244265318,-2.98023217215615e-10,7.10542719878232e-17]]],[0,"26R5ll6SNGP5ArlFhrFOzH",1,0],[1,0.0765028968453407,0.0984558537602425,1.90734859017994e-8],[3,-1.5454308319985125e-8,-1.5454308319985125e-8,0.7071067811865472,0.7071067811865472],[1,0,-0.0000025044778683729224,90]],[44,"Bip001 Spine1",3,[4],[0,"78+5xpqyNL2aHMIBr4YHvg",1,0],[1,0.150201484560966,-0.000119601711048745,-3.31727090241429e-10]],[16,"Bip001 L Clavicle",4,[-26],[0,"c67UVUfoFCNLAcx8dX7SW1",1,0],[1,0,0.0000435078145528678,0.0232834853231907],[3,0.6087613827170933,-0.0002434881366867595,0.7933532758994495,0.0003150325566206266],[1,179.9558877717535,-104.99999523006848,0.01165464185401893]],[16,"Bip001 L UpperArm",17,[-27],[0,"66qUHYCHZNMoAvIMM8jTZn",1,0],[1,0.272405058145523,4.54747340722069e-15,0],[3,0.004462069723208538,0.4381802273458216,-0.0019434620153348766,0.8988739629404916],[1,0.5572016837940187,51.97620557313351,0.02386521946895269]],[16,"Bip001 L Forearm",18,[-28],[0,"503RTkgyFOwZRj7QxbXFGT",1,0],[1,0.263291478157043,0,0],[3,-2.7197715504795845e-20,-3.0893820368327117e-17,-0.0008803606294924629,0.9999996124825059],[1,-6.233264281423144e-18,-3.5401778996822195e-15,-0.10088191006996569]],[6,"Bip001 L Hand",19,[[7,"sword01",-29,[0,"98Mxm4C+NAIp1/ms1CXDWg",1,0],[1,0.0919111594557762,0.0340489186346531,-0.14926840364933],[3,0.6409670678902519,-0.3070256396863465,-0.5278458569202463,-0.4650540030872693],[1,-112.37885078724646,75.2002383569922,5.587571211625747]]],[0,"7cWlWOkFtKX6ILXuZfhYqO",1,0],[1,0.199572831392288,-5.9604643443123e-10,1.42108543975646e-16],[3,-0.7068252124052271,1.0458620867947887e-8,1.0614867442646885e-8,0.7073882378922519],[1,-89.95437890588059,0.0000017075473071153707,1.3340228971442967e-8]],[16,"Bip001 R Clavicle",4,[-30],[0,"9fRB6KFOpAz6pb5W8NAqZg",1,0],[1,0,0.0000436370064562652,-0.0232834853231907],[3,-0.6087613827171046,0.00024128768333211222,0.793353275899464,0.0003167210153793466],[1,-179.95597003338875,104.99999512047448,0.011961643569376679]],[16,"Bip001 R UpperArm",21,[-31],[0,"a72KzY4dJDrb/Ifgjl7CSF",1,0],[1,0.272405058145523,6.82120985672115e-14,-1.42108543975646e-16],[3,-0.030114175418424236,-0.43755956999841955,0.05059855375302801,0.897259463867486],[1,-0.5631334715243025,-51.96038786477057,6.727854372934277]],[16,"Bip001 R Forearm",22,[-32],[0,"5eAc4VAlRExZ6nABKN5Ihq",1,0],[1,0.263291418552399,0,-7.62939436071974e-8],[3,-8.302567498559346e-18,-5.588016764292516e-17,-0.13176086831298384,0.9912815309393233],[1,-1.8510999406615195e-15,-6.705762043264369e-15,-15.14271605062808]],[6,"Bip001 R Hand",23,[[7,"shield01",-33,[0,"4f4kzbhYBIMIVjz0nZTcvw",1,0],[1,0.124533005058765,-0.00692871073260903,0.0576667860150337],[3,0.5417342069004817,-0.1379658103002438,0.11668003843623054,0.8208990515846776],[1,67.2841187503732,-20.685866498064005,2.411917394086867]]],[0,"19JEI2tAtAo5mcAZ7XSRWH",1,0],[1,0.199572905898094,8.88178399847791e-18,0],[3,0.7068252124052272,-1.9327187937127104e-17,1.9311804031753923e-17,0.707388237892252],[1,89.95437890588059,-3.1308585900006548e-15,-7.956237644289779e-23]],[6,"Bip001 Head",4,[[31,"Bip001 HeadNub",-34,[0,"ebvw49UjBMKoIvQOBhsyUF",1,0],[1,0.475234657526016,-1.45519149031062e-13,2.99510855318999e-20]]],[0,"4ckJuubwNG3KpsMgkuxo12",1,0],[1,0.0547203049063683,-1.38777874976217e-19,2.71050537062924e-22],[3,-7.265599787883251e-14,1.1042733174299354e-9,-0.0003988305609355657,0.9999999204670887],[1,4.214242912539149e-11,1.2654042790710837e-7,-0.04570261697650697]],[10,"shield",2,[[13,-35,[5,"ffoVYmt2NOmIBz5DHpacF8"],[3],[3],1,4,5]],[0,"2fgzyRcBxNmZKzBdJpnT0Q",1,0],[3,0.9999999999999878,0,0,-1.569582366300871e-7],[1,87.7489852905273,87.7489852905273,87.7489852905273],[1,-179.99998201391097,0,0]],[10,"sword",2,[[13,-36,[5,"9aCVBuMeZPv6so1VxT6c40"],[6],[3],1,7,8]],[0,"d0xEUY/HZBVZJ0EMEz3doQ",1,0],[3,0.9999999999999878,0,0,-1.569582366300871e-7],[1,87.7489852905273,87.7489852905273,87.7489852905273],[1,-179.99998201391097,0,0]],[20,"shield01",2,[[13,-37,[5,"ca1srfPsJJgKKJww9GO/JE"],[9],[3],1,10,11]],[0,"464KPea2NOibwROP5moUvA",1,0],[1,-0.00499999988824129,0,0.00499999988824129],[3,0.9999999999999878,0,0,-1.569582366300871e-7],[1,87.7489852905273,87.7489852905273,87.7489852905273],[1,-179.99998201391097,0,0]]],0,[0,5,1,0,0,1,0,-1,2,0,-1,6,0,-2,5,0,-3,26,0,-4,27,0,-5,28,0,-1,8,0,-2,12,0,-3,16,0,-1,17,0,-2,21,0,-3,25,0,1,5,0,-2,7,0,0,6,0,-1,9,0,-1,10,0,-1,11,0,1,11,0,-1,13,0,-1,14,0,-1,15,0,1,15,0,-1,18,0,-1,19,0,-1,20,0,1,20,0,-1,22,0,-1,23,0,-1,24,0,1,24,0,1,25,0,0,26,0,0,27,0,0,28,0,8,1,3,1,7,4,1,16,37],[0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,2,3,-1,2,3,-1,2,3,-1,2,3,-1,4],[6,32,33,6,34,35,6,36,37,38,39,40,8,8]],[[[12,".bin",77088,4069446529,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":70128,"length":6960,"count":3480,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":70128,"count":974,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]]},"minPosition",8,[1,-0.006235902663320303,-0.022199034690856934,-0.00308204535394907],"maxPosition",8,[1,0.006235902663320303,0.0000021968080545775592,0.0029080540407449007]]]],0,0,[],[],[]],[[[23,"Skin-0",2507836796,["RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh","RootNode/Bip001/Bip001 Pelvis","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf","RootNode/Bip001","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf/Bip001 R Foot","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 HeadNub","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf/Bip001 L Foot","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/shield01"],[[[7,13.330132484436035,0.5659459233283997,-86.72872161865234,0,86.68508911132812,2.7542707920074463,13.341398239135742,0,2.808293342590332,-87.70392608642578,-0.14067713916301727,0,0.719279408454895,0.022746119648218155,0.1780078411102295,1],[7,-13.330143928527832,-0.5657054781913757,-86.72872924804688,0,86.68508911132812,2.7542707920074463,-13.34140396118164,0,2.8082568645477295,-87.70392608642578,0.14043928682804108,0,0.7192792892456055,0.022746119648218155,-0.17800788581371307,1],[7,0.00012169029650976881,0.0002419860102236271,87.74899291992188,0,-87.74898529052734,-0.00001708502350084018,0.00012169034744147211,0,0.000017085358194890432,-87.74899291992188,0.0002419859665678814,0,-0.738336980342865,6.5663993339959426e-12,0.0000010239258472211077,1],[7,9.57883514729474e-8,-0.00012308494478929788,87.74899291992188,0,-87.74895477294922,0.06985900551080704,1.9377911542051152e-7,0,-0.06985900551080704,-87.74896240234375,-0.00012308482837397605,0,-0.8148396015167236,0.0007684377487748861,2.1313388831600832e-9,1],[7,-13.329378128051758,-0.5835267305374146,-86.72872924804688,0,86.68132781982422,2.870192527770996,-13.341405868530273,0,2.9255402088165283,-87.7000961303711,0.14043459296226501,0,0.3512277603149414,0.023215843364596367,-0.17800790071487427,1],[7,0.00012029569188598543,87.74899291992188,-5.373075573876507e-15,0,-0.000017085358194890432,2.3417063427233487e-11,-87.74898529052734,0,-87.74899291992188,0.00012029569188598543,0.000017085358194890432,0,3.742711869592075e-12,-5.034101432245029e-17,-0.738336980342865,1],[7,13.329362869262695,0.5837728977203369,-86.72872161865234,0,86.68132781982422,2.870190143585205,13.341397285461426,0,2.9255752563476562,-87.7000961303711,-0.14067858457565308,0,0.3512278199195862,0.023215826600790024,0.1780078411102295,1],[7,0.000003835630195681006,0.00012029569188598543,-87.74899291992188,0,87.74898529052734,-0.000017085363651858643,0.0000038356070035661105,0,-0.000017085358194890432,-87.74899291992188,-0.00012029569188598543,0,0.08038292825222015,0.021714111790060997,-0.16770152747631073,1],[7,0.0001178546590381302,-0.00012308491568546742,87.74899291992188,0,-87.74898529052734,-0.000017085523722926155,0.00011785465176217258,0,0.000017085358194890432,-87.74899291992188,-0.00012308494478929788,0,-1.6451982259750366,5.87142210406455e-7,0.0000022096469365351368,1],[7,0.0001178546590381302,-0.00012308491568546742,87.74899291992188,0,-87.74898529052734,-0.000017085523722926155,0.00011785465176217258,0,0.000017085358194890432,-87.74899291992188,-0.00012308494478929788,0,-1.1699634790420532,-5.1139195988980646e-8,0.0000015713648053861107,1],[7,-84.7590103149414,-0.00011930296022910625,22.711111068725586,0,22.711111068725586,0.000016954663806245662,84.7590103149414,0,-0.00011962600547121838,87.74899291992188,0.00001450093350285897,0,0.26615607738494873,4.7347434417588374e-8,1.0832682847976685,1],[7,84.7590103149414,-0.00012128843081882223,22.711111068725586,0,22.711111068725586,0.000016954663806245662,-84.7590103149414,0,0.00011276743316557258,87.74899291992188,0.00004776870264322497,0,0.26615607738494873,4.734742375944734e-8,-1.0832682847976685,1],[7,9.57883514729474e-8,-0.00012308494478929788,87.74899291992188,0,-87.74895477294922,0.06985900551080704,1.9377911542051152e-7,0,-0.06985900551080704,-87.74896240234375,-0.00012308482837397605,0,-0.9650411605834961,0.0008880393579602242,2.4630661954461175e-9,1],[7,9.57883514729474e-8,-0.00012308494478929788,87.74899291992188,0,-87.74895477294922,0.06985900551080704,1.9377911542051152e-7,0,-0.06985900551080704,-87.74896240234375,-0.00012308482837397605,0,-1.1152427196502686,0.0009316118084825575,2.583918634613269e-9,1],[7,0.000003835630195681006,0.00012029569188598543,-87.74899291992188,0,87.74898529052734,-0.000017085363651858643,0.0000038356070035661105,0,-0.000017085358194890432,-87.74899291992188,-0.00012029569188598543,0,0.08038290590047836,0.0217141043394804,0.16770148277282715,1],[7,34.319801330566406,0.7709546685218811,80.75544738769531,0,80.75911712646484,-0.3673746883869171,-34.31785202026367,0,0.0365816168487072,87.74483489990234,-0.853227436542511,0,0.8495007157325745,-0.006890855263918638,-0.672168493270874,1],[7,-34.105628967285156,3.229346752166748,80.7852783203125,0,80.19358825683594,-9.797160148620605,34.247459411621094,0,10.280043601989746,87.1405258178711,0.8565954566001892,0,0.8434666395187378,-0.10610441118478775,0.6714277267456055,1],[7,34.318382263183594,0.8313809037208557,80.75544738769531,0,80.75962829589844,-0.22517983615398407,-34.317848205566406,0,-0.11791250109672546,87.7447509765625,-0.8532273173332214,0,0.5862204432487488,-0.005858692806214094,-0.6721684336662292,1],[7,34.318382263183594,-80.75476837158203,0.8956841230392456,0,80.75962829589844,34.31765365600586,-0.25250619649887085,0,-0.11791250109672546,0.9230960011482239,87.74404907226562,0,0.38664767146110535,0.6721636056900024,-0.0063939220272004604,1],[7,-33.76499557495117,-5.791998386383057,80.7852783203125,0,79.96836853027344,11.491525650024414,34.24745178222656,0,-12.840116500854492,86.80025482177734,0.8565958738327026,0,0.5877475142478943,0.04913555085659027,0.6714276671409607,1],[7,-33.76499557495117,80.7806396484375,5.856326103210449,0,79.96836853027344,34.256595611572266,-11.464248657226562,0,-12.840116500854492,0.9257150888442993,-86.7995376586914,0,0.3881746232509613,0.671466588973999,-0.04860087111592293,1],[7,-26.09381103515625,47.70235824584961,-68.8729248046875,0,72.14217376708984,-23.88349151611328,-43.87446212768555,0,-42.596981048583984,-69.67027282714844,-32.11593246459961,0,0.23747046291828156,0.08072908967733383,-0.6914553046226501,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[12,".bin",696,2470630447,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":648,"length":48,"count":24,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":648,"count":9,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.009095229208469391,-0.00829001609236002,-0.0038153051864355803],"maxPosition",8,[1,-0.002438712865114212,-0.0038237078115344048,0.0021244001109153032]]]],0,0,[],[],[]],[[[12,".bin",2280,1932649666,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":2016,"length":264,"count":132,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":2016,"count":28,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}]},"minPosition",8,[1,0.004531483631581068,-0.006827499717473984,-0.009057947434484959],"maxPosition",8,[1,0.00610683299601078,-0.003189224749803543,0.0015691547887399793]]]],0,0,[],[],[]],[[[33,"Take 001",".bin",30,2,true,1.3000000397364297,3980485045,[[1,15272,33,6,33]],[[[{},"modifiers",12,[[-1,"position"],1,0],"data",11,[{"keys":0},"values",4,[34,99,22,33]]],[{},"modifiers",12,[[-2,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[1,396,132,38,33]]],[{},"modifiers",12,[[-3,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,924,3,22,1]]],[{},"modifiers",12,[[-4,"position"],1,0],"data",11,[{"keys":0},"values",4,[1,936,99,22,33]]],[{},"modifiers",12,[[-5,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[1,1332,132,38,33]]],[{},"modifiers",12,[[-6,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,1860,3,22,1]]],[{},"modifiers",12,[[-7,"position"],1,0],"data",11,[{"keys":0},"values",4,[1,1872,99,22,33]]],[{},"modifiers",12,[[-8,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[1,2268,132,38,33]]],[{},"modifiers",12,[[-9,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,2796,3,22,1]]],[{},"modifiers",12,[[-10,"position"],1,0],"data",11,[{"keys":0},"values",4,[1,2808,99,22,33]]],[{},"modifiers",12,[[-11,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[1,3204,132,38,33]]],[{},"modifiers",12,[[-12,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,3732,3,22,1]]],[{},"modifiers",12,[[-13,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[1,3744,132,38,33]]],[{},"modifiers",12,[[-14,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,4272,3,22,1]]],[{},"modifiers",12,[[-15,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,4284,3,22,1]]],[{},"modifiers",12,[[-16,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[1,4296,132,38,33]]],[{},"modifiers",12,[[-17,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,4824,3,22,1]]],[{},"modifiers",12,[[-18,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,4836,3,22,1]]],[{},"modifiers",12,[[-19,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[1,4848,132,38,33]]],[{},"modifiers",12,[[-20,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,5376,3,22,1]]],[{},"modifiers",12,[[-21,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,5388,3,22,1]]],[{},"modifiers",12,[[-22,"position"],1,0],"data",11,[{"keys":0},"values",4,[1,5400,99,22,33]]],[{},"modifiers",12,[[-23,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[1,5796,132,38,33]]],[{},"modifiers",12,[[-24,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,6324,3,22,1]]],[{},"modifiers",12,[[-25,"position"],1,0],"data",11,[{"keys":0},"values",4,[1,6336,99,22,33]]],[{},"modifiers",12,[[-26,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[1,6732,132,38,33]]],[{},"modifiers",12,[[-27,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,7260,3,22,1]]],[{},"modifiers",12,[[-28,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[1,7272,132,38,33]]],[{},"modifiers",12,[[-29,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,7800,3,22,1]]],[{},"modifiers",12,[[-30,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,7812,3,22,1]]],[{},"modifiers",12,[[-31,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[1,7824,132,38,33]]],[{},"modifiers",12,[[-32,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,8352,3,22,1]]],[{},"modifiers",12,[[-33,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,8364,3,22,1]]],[{},"modifiers",12,[[-34,"position"],1,0],"data",11,[{"keys":0},"values",4,[1,8376,99,22,33]]],[{},"modifiers",12,[[-35,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[1,8772,132,38,33]]],[{},"modifiers",12,[[-36,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,9300,3,22,1]]],[{},"modifiers",12,[[-37,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[1,9312,132,38,33]]],[{},"modifiers",12,[[-38,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,9840,3,22,1]]],[{},"modifiers",12,[[-39,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,9852,3,22,1]]],[{},"modifiers",12,[[-40,"position"],1,0],"data",11,[{"keys":0},"values",4,[1,9864,99,22,33]]],[{},"modifiers",12,[[-41,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[1,10260,132,38,33]]],[{},"modifiers",12,[[-42,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,10788,3,22,1]]],[{},"modifiers",12,[[-43,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[1,10800,132,38,33]]],[{},"modifiers",12,[[-44,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,11328,3,22,1]]],[{},"modifiers",12,[[-45,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,11340,3,22,1]]],[{},"modifiers",12,[[-46,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[1,11352,132,38,33]]],[{},"modifiers",12,[[-47,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,11880,3,22,1]]],[{},"modifiers",12,[[-48,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,11892,3,22,1]]],[{},"modifiers",12,[[-49,"position"],1,0],"data",11,[{"keys":0},"values",4,[1,11904,99,22,33]]],[{},"modifiers",12,[[-50,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[1,12300,132,38,33]]],[{},"modifiers",12,[[-51,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,12828,3,22,1]]],[{},"modifiers",12,[[-52,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[1,12840,132,38,33]]],[{},"modifiers",12,[[-53,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,13368,3,22,1]]],[{},"modifiers",12,[[-54,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,13380,3,22,1]]],[{},"modifiers",12,[[-55,"position"],1,0],"data",11,[{"keys":0},"values",4,[1,13392,99,22,33]]],[{},"modifiers",12,[[-56,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,13788,3,22,1]]],[{},"modifiers",12,[[-57,"rotation"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,13800,4,38,1]]],[{},"modifiers",12,[[-58,"rotation"],1,0],"data",11,[{"keys":0},"values",4,[1,13816,132,38,33]]],[{},"modifiers",12,[[-59,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,14344,3,22,1]]],[{},"modifiers",12,[[-60,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,14356,3,22,1]]],[{},"modifiers",12,[[-61,"position"],1,0],"data",11,[{"keys":0},"values",4,[1,14368,99,22,33]]],[{},"modifiers",12,[[-62,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,14764,3,22,1]]],[{},"modifiers",12,[[-63,"rotation"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,14776,4,38,1]]],[{},"modifiers",12,[[-64,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,14792,3,22,1]]],[{},"modifiers",12,[[-65,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,14804,3,22,1]]],[{},"modifiers",12,[[-66,"rotation"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,14816,4,38,1]]],[{},"modifiers",12,[[-67,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,14832,3,22,1]]],[{},"modifiers",12,[[-68,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,14844,3,22,1]]],[{},"modifiers",12,[[-69,"rotation"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,14856,4,38,1]]],[{},"modifiers",12,[[-70,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,14872,3,22,1]]],[{},"modifiers",12,[[-71,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,14884,3,22,1]]],[{},"modifiers",12,[[-72,"rotation"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,14896,4,38,1]]],[{},"modifiers",12,[[-73,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,14912,3,22,1]]],[{},"modifiers",12,[[-74,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,14924,3,22,1]]],[{},"modifiers",12,[[-75,"rotation"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,14936,4,38,1]]],[{},"modifiers",12,[[-76,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,14952,3,22,1]]],[{},"modifiers",12,[[-77,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,14964,3,22,1]]],[{},"modifiers",12,[[-78,"rotation"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,14976,4,38,1]]],[{},"modifiers",12,[[-79,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,14992,3,22,1]]],[{},"modifiers",12,[[-80,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,15004,3,22,1]]],[{},"modifiers",12,[[-81,"rotation"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,15016,4,38,1]]],[{},"modifiers",12,[[-82,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,15032,3,22,1]]],[{},"modifiers",12,[[-83,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,15044,3,22,1]]],[{},"modifiers",12,[[-84,"rotation"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,15056,4,38,1]]],[{},"modifiers",12,[[-85,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,15072,3,22,1]]],[{},"modifiers",12,[[-86,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,15084,3,22,1]]],[{},"modifiers",12,[[-87,"rotation"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,15096,4,38,1]]],[{},"modifiers",12,[[-88,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,15112,3,22,1]]],[{},"modifiers",12,[[-89,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,15124,3,22,1]]],[{},"modifiers",12,[[-90,"rotation"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,15136,4,38,1]]],[{},"modifiers",12,[[-91,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,15152,3,22,1]]],[{},"modifiers",12,[[-92,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,15164,3,22,1]]],[{},"modifiers",12,[[-93,"rotation"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,15176,4,38,1]]],[{},"modifiers",12,[[-94,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,15192,3,22,1]]],[{},"modifiers",12,[[-95,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,15204,3,22,1]]],[{},"modifiers",12,[[-96,"rotation"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,15216,4,38,1]]],[{},"modifiers",12,[[-97,"position"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,15232,3,22,1]]],[{},"modifiers",12,[[-98,"scale"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,15244,3,22,1]]],[{},"modifiers",12,[[-99,"rotation"],1,0],"data",11,[{"keys":-1,"interpolate":false},"values",4,[1,15256,4,38,1]]]],11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11]],[4,"RootNode/Bip001"],[4,"RootNode/Bip001/Bip001 Footsteps"],[4,"RootNode/Bip001/Bip001 Pelvis/Bip001 Spine"],[4,"RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh"],[4,"RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf"],[4,"RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf/Bip001 L Foot"],[4,"RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf/Bip001 L Foot/Bip001 L Toe0"],[4,"RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh"],[4,"RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf"],[4,"RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf/Bip001 R Foot"],[4,"RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf/Bip001 R Foot/Bip001 R Toe0"],[4,"RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1"],[4,"RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm"],[4,"RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm"],[4,"RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand"],[4,"RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm"],[4,"RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm"],[4,"RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand"],[4,"RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/shield01"],[4,"RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head"],[4,"RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 HeadNub"],[4,"RootNode"],[4,"RootNode/soldier"],[4,"RootNode/Bip001/Bip001 Pelvis"],[4,"RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf/Bip001 L Foot/Bip001 L Toe0/Bip001 L Toe0Nub"],[4,"RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf/Bip001 R Foot/Bip001 R Toe0/Bip001 R Toe0Nub"],[4,"RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck"],[4,"RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle"],[4,"RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/sword01"],[4,"RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle"],[4,"RootNode/shield"],[4,"RootNode/sword"],[4,"RootNode/shield01"]],0,[0,-1,1,0,-1,1,0,-1,1,0,-1,2,0,-1,2,0,-1,2,0,-1,3,0,-1,3,0,-1,3,0,-1,4,0,-1,4,0,-1,4,0,-1,5,0,-1,5,0,-1,5,0,-1,6,0,-1,6,0,-1,6,0,-1,7,0,-1,7,0,-1,7,0,-1,8,0,-1,8,0,-1,8,0,-1,9,0,-1,9,0,-1,9,0,-1,10,0,-1,10,0,-1,10,0,-1,11,0,-1,11,0,-1,11,0,-1,12,0,-1,12,0,-1,12,0,-1,13,0,-1,13,0,-1,13,0,-1,14,0,-1,14,0,-1,14,0,-1,15,0,-1,15,0,-1,15,0,-1,16,0,-1,16,0,-1,16,0,-1,17,0,-1,17,0,-1,17,0,-1,18,0,-1,18,0,-1,18,0,-1,19,0,-1,19,0,-1,19,0,-1,20,0,-1,20,0,-1,20,0,-1,21,0,-1,21,0,-1,21,0,-1,22,0,-1,22,0,-1,22,0,-1,23,0,-1,23,0,-1,23,0,-1,24,0,-1,24,0,-1,24,0,-1,25,0,-1,25,0,-1,25,0,-1,26,0,-1,26,0,-1,26,0,-1,27,0,-1,27,0,-1,27,0,-1,28,0,-1,28,0,-1,28,0,-1,29,0,-1,29,0,-1,29,0,-1,30,0,-1,30,0,-1,30,0,-1,31,0,-1,31,0,-1,31,0,-1,32,0,-1,32,0,-1,32,0,-1,33,0,-1,33,0,-1,33,99],[],[],[]],[[[23,"Skin-2",1928083474,["RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/sword01"],[[[7,-0.000007191588792920811,-0.00005849258377566002,-87.7490005493164,0,24.115726470947266,-84.3700942993164,0.0000542638408660423,0,-84.37010192871094,-24.115724563598633,0.000022989974240772426,0,-0.00041664036689326167,-0.5413689017295837,0.47052377462387085,1]],8]]],0,0,[],[],[]],[[[23,"Skin-3",3487038830,["RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/shield01"],[[[7,-26.09381103515625,47.70235824584961,-68.8729248046875,0,72.14216613769531,-23.883501052856445,-43.87446594238281,0,-42.59699249267578,-69.6702651977539,-32.11592483520508,0,0.24138452112674713,0.08198083937168121,-0.6857008934020996,1]],8]]],0,0,[],[],[]],[[[12,".bin",6960,3939686354,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":6480,"length":480,"count":240,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":6480,"count":90,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.009095229208469391,-0.00861329771578312,-0.0038153051864355803],"maxPosition",8,[1,-0.0022758706472814083,-0.0038237078115344048,0.002340445527806878]]]],0,0,[],[],[]],[[[23,"Skin-1",1546018204,["RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/shield01"],[[[7,-26.09381103515625,47.70235824584961,-68.8729248046875,0,72.14216613769531,-23.883501052856445,-43.87446594238281,0,-42.59699249267578,-69.6702651977539,-32.11592483520508,0,0.23747046291828156,0.08072908967733383,-0.6914553046226501,1]],8]]],0,0,[],[],[]]]]
